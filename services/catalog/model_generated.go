/*
 * Copyright Â© 2022 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * Search Catalog service
 *
 * With the Metadata Catalog in Splunk Cloud Services you can create and manage knowledge objects such as datasets, fields, rules, actions, and dashboards.
 *
 * API version: v2beta1.4 (recommended default)
 * Generated by: OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
 */

package catalog

import (
	"bytes"
	"encoding/json"
)

// Action : A complete action as rendered in POST, PATCH, and GET responses.
type Action struct {
	aliasAction  *AliasAction
	autoKvAction *AutoKvAction
	evalAction   *EvalAction
	lookupAction *LookupAction
	regexAction  *RegexAction
	raw          interface{}
}

// MakeActionFromAliasAction creates a new Action from an instance of AliasAction
func MakeActionFromAliasAction(f AliasAction) Action {
	return Action{aliasAction: &f}
}

// IsAliasAction checks if the Action is a AliasAction
func (m Action) IsAliasAction() bool {
	return m.aliasAction != nil
}

// AliasAction returns AliasAction if IsAliasAction() is true, nil otherwise
func (m Action) AliasAction() *AliasAction {
	return m.aliasAction
}

// MakeActionFromAutoKvAction creates a new Action from an instance of AutoKvAction
func MakeActionFromAutoKvAction(f AutoKvAction) Action {
	return Action{autoKvAction: &f}
}

// IsAutoKvAction checks if the Action is a AutoKvAction
func (m Action) IsAutoKvAction() bool {
	return m.autoKvAction != nil
}

// AutoKvAction returns AutoKvAction if IsAutoKvAction() is true, nil otherwise
func (m Action) AutoKvAction() *AutoKvAction {
	return m.autoKvAction
}

// MakeActionFromEvalAction creates a new Action from an instance of EvalAction
func MakeActionFromEvalAction(f EvalAction) Action {
	return Action{evalAction: &f}
}

// IsEvalAction checks if the Action is a EvalAction
func (m Action) IsEvalAction() bool {
	return m.evalAction != nil
}

// EvalAction returns EvalAction if IsEvalAction() is true, nil otherwise
func (m Action) EvalAction() *EvalAction {
	return m.evalAction
}

// MakeActionFromLookupAction creates a new Action from an instance of LookupAction
func MakeActionFromLookupAction(f LookupAction) Action {
	return Action{lookupAction: &f}
}

// IsLookupAction checks if the Action is a LookupAction
func (m Action) IsLookupAction() bool {
	return m.lookupAction != nil
}

// LookupAction returns LookupAction if IsLookupAction() is true, nil otherwise
func (m Action) LookupAction() *LookupAction {
	return m.lookupAction
}

// MakeActionFromRegexAction creates a new Action from an instance of RegexAction
func MakeActionFromRegexAction(f RegexAction) Action {
	return Action{regexAction: &f}
}

// IsRegexAction checks if the Action is a RegexAction
func (m Action) IsRegexAction() bool {
	return m.regexAction != nil
}

// RegexAction returns RegexAction if IsRegexAction() is true, nil otherwise
func (m Action) RegexAction() *RegexAction {
	return m.regexAction
}

// MakeActionFromRawInterface creates a new Action from a raw interface{}
func MakeActionFromRawInterface(f interface{}) Action {
	return Action{raw: f}
}

// IsRawInterface checks if the Action is an interface{} (unknown type)
func (m Action) IsRawInterface() bool {
	return m.raw != nil
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m Action) RawInterface() interface{} {
	return m.raw
}

// UnmarshalJSON unmarshals Action using the "kind" property
func (m *Action) UnmarshalJSON(b []byte) (err error) {
	type discriminator struct {
		Kind string `json:"kind"`
	}
	var d discriminator
	err = json.Unmarshal(b, &d)
	if err != nil {
		return err
	}
	// Resolve into respective struct based on the discriminator value
	switch d.Kind {
	case "ALIAS":
		m.aliasAction = &AliasAction{}
		return json.Unmarshal(b, m.aliasAction)
	case "AUTOKV":
		m.autoKvAction = &AutoKvAction{}
		return json.Unmarshal(b, m.autoKvAction)
	case "EVAL":
		m.evalAction = &EvalAction{}
		return json.Unmarshal(b, m.evalAction)
	case "LOOKUP":
		m.lookupAction = &LookupAction{}
		return json.Unmarshal(b, m.lookupAction)
	case "REGEX":
		m.regexAction = &RegexAction{}
		return json.Unmarshal(b, m.regexAction)
	}
	// Unknown discriminator value (this type may not yet be supported)
	// unmarhsal to raw interface
	var raw interface{}
	err = json.Unmarshal(b, &raw)
	if err != nil {
		return err
	}
	m.raw = raw
	return nil
}

// MarshalJSON marshals Action using the appropriate struct field
func (m Action) MarshalJSON() ([]byte, error) {
	if m.IsAliasAction() {
		return json.Marshal(m.aliasAction)
	} else if m.IsAutoKvAction() {
		return json.Marshal(m.autoKvAction)
	} else if m.IsEvalAction() {
		return json.Marshal(m.evalAction)
	} else if m.IsLookupAction() {
		return json.Marshal(m.lookupAction)
	} else if m.IsRegexAction() {
		return json.Marshal(m.regexAction)
	}
	// None of the structs are populated, send raw
	return json.Marshal(m.raw)
}

// Properties common across all action kinds as rendered in POST, PATCH, and GET responses and alos for creating a new action using a POST request.
type ActionCommon struct {
	// A unique action ID.
	Id *string `json:"id,omitempty"`
	// The rule that this action is part of.
	Ruleid *string `json:"ruleid,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// ActionPatch : Property values to be set in an existing action using a PATCH request.
// ActionPatch is AliasActionPatch, AutoKvActionPatch, EvalActionPatch, LookupActionPatch, RegexActionPatch, (or interface{} if no matches are found)
type ActionPatch struct {
	actionPatch interface{}
	isRaw       bool
}

// UnmarshalJSON unmarshals ActionPatch into AliasActionPatch, AutoKvActionPatch, EvalActionPatch, LookupActionPatch, RegexActionPatch, or interface{} if no matches are found
func (m *ActionPatch) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testAliasActionPatch AliasActionPatch
	if err = attempt(&testAliasActionPatch); err == nil {
		m.actionPatch = testAliasActionPatch
		return nil
	}
	var testAutoKvActionPatch AutoKvActionPatch
	if err = attempt(&testAutoKvActionPatch); err == nil {
		m.actionPatch = testAutoKvActionPatch
		return nil
	}
	var testEvalActionPatch EvalActionPatch
	if err = attempt(&testEvalActionPatch); err == nil {
		m.actionPatch = testEvalActionPatch
		return nil
	}
	var testLookupActionPatch LookupActionPatch
	if err = attempt(&testLookupActionPatch); err == nil {
		m.actionPatch = testLookupActionPatch
		return nil
	}
	var testRegexActionPatch RegexActionPatch
	if err = attempt(&testRegexActionPatch); err == nil {
		m.actionPatch = testRegexActionPatch
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.actionPatch = raw
	return nil
}

// MarshalJSON marshals ActionPatch using ActionPatch.ActionPatch
func (m ActionPatch) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.actionPatch)
}

// MakeActionPatchFromAliasActionPatch creates a new ActionPatch from an instance of AliasActionPatch
func MakeActionPatchFromAliasActionPatch(f AliasActionPatch) ActionPatch {
	return ActionPatch{actionPatch: f}
}

// IsAliasActionPatch checks if the ActionPatch is a AliasActionPatch
func (m ActionPatch) IsAliasActionPatch() bool {
	_, ok := m.actionPatch.(AliasActionPatch)
	return ok
}

// AliasActionPatch returns AliasActionPatch if IsAliasActionPatch() is true, nil otherwise
func (m ActionPatch) AliasActionPatch() *AliasActionPatch {
	if v, ok := m.actionPatch.(AliasActionPatch); ok {
		return &v
	}
	return nil
}

// MakeActionPatchFromAutoKvActionPatch creates a new ActionPatch from an instance of AutoKvActionPatch
func MakeActionPatchFromAutoKvActionPatch(f AutoKvActionPatch) ActionPatch {
	return ActionPatch{actionPatch: f}
}

// IsAutoKvActionPatch checks if the ActionPatch is a AutoKvActionPatch
func (m ActionPatch) IsAutoKvActionPatch() bool {
	_, ok := m.actionPatch.(AutoKvActionPatch)
	return ok
}

// AutoKvActionPatch returns AutoKvActionPatch if IsAutoKvActionPatch() is true, nil otherwise
func (m ActionPatch) AutoKvActionPatch() *AutoKvActionPatch {
	if v, ok := m.actionPatch.(AutoKvActionPatch); ok {
		return &v
	}
	return nil
}

// MakeActionPatchFromEvalActionPatch creates a new ActionPatch from an instance of EvalActionPatch
func MakeActionPatchFromEvalActionPatch(f EvalActionPatch) ActionPatch {
	return ActionPatch{actionPatch: f}
}

// IsEvalActionPatch checks if the ActionPatch is a EvalActionPatch
func (m ActionPatch) IsEvalActionPatch() bool {
	_, ok := m.actionPatch.(EvalActionPatch)
	return ok
}

// EvalActionPatch returns EvalActionPatch if IsEvalActionPatch() is true, nil otherwise
func (m ActionPatch) EvalActionPatch() *EvalActionPatch {
	if v, ok := m.actionPatch.(EvalActionPatch); ok {
		return &v
	}
	return nil
}

// MakeActionPatchFromLookupActionPatch creates a new ActionPatch from an instance of LookupActionPatch
func MakeActionPatchFromLookupActionPatch(f LookupActionPatch) ActionPatch {
	return ActionPatch{actionPatch: f}
}

// IsLookupActionPatch checks if the ActionPatch is a LookupActionPatch
func (m ActionPatch) IsLookupActionPatch() bool {
	_, ok := m.actionPatch.(LookupActionPatch)
	return ok
}

// LookupActionPatch returns LookupActionPatch if IsLookupActionPatch() is true, nil otherwise
func (m ActionPatch) LookupActionPatch() *LookupActionPatch {
	if v, ok := m.actionPatch.(LookupActionPatch); ok {
		return &v
	}
	return nil
}

// MakeActionPatchFromRegexActionPatch creates a new ActionPatch from an instance of RegexActionPatch
func MakeActionPatchFromRegexActionPatch(f RegexActionPatch) ActionPatch {
	return ActionPatch{actionPatch: f}
}

// IsRegexActionPatch checks if the ActionPatch is a RegexActionPatch
func (m ActionPatch) IsRegexActionPatch() bool {
	_, ok := m.actionPatch.(RegexActionPatch)
	return ok
}

// RegexActionPatch returns RegexActionPatch if IsRegexActionPatch() is true, nil otherwise
func (m ActionPatch) RegexActionPatch() *RegexActionPatch {
	if v, ok := m.actionPatch.(RegexActionPatch); ok {
		return &v
	}
	return nil
}

// MakeActionPatchFromRawInterface creates a new ActionPatch from a raw interface{}
func MakeActionPatchFromRawInterface(f interface{}) ActionPatch {
	return ActionPatch{
		actionPatch: f,
		isRaw:       true,
	}
}

// IsRawInterface checks if the ActionPatch is an interface{} (unknown type)
func (m ActionPatch) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m ActionPatch) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.actionPatch
}

// Property values common across action kinds for setting existing actions using a PATCH request.
type ActionPatchCommon struct {
	// The name of the user who owns this action. This value is obtained from the bearer token if not present.
	Owner *string `json:"owner,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// ActionPost : Initial property values for creating a new action using a POST request.
type ActionPost struct {
	aliasActionPost  *AliasActionPost
	autoKvActionPost *AutoKvActionPost
	evalActionPost   *EvalActionPost
	lookupActionPost *LookupActionPost
	regexActionPost  *RegexActionPost
	raw              interface{}
}

// MakeActionPostFromAliasActionPost creates a new ActionPost from an instance of AliasActionPost
func MakeActionPostFromAliasActionPost(f AliasActionPost) ActionPost {
	return ActionPost{aliasActionPost: &f}
}

// IsAliasActionPost checks if the ActionPost is a AliasActionPost
func (m ActionPost) IsAliasActionPost() bool {
	return m.aliasActionPost != nil
}

// AliasActionPost returns AliasActionPost if IsAliasActionPost() is true, nil otherwise
func (m ActionPost) AliasActionPost() *AliasActionPost {
	return m.aliasActionPost
}

// MakeActionPostFromAutoKvActionPost creates a new ActionPost from an instance of AutoKvActionPost
func MakeActionPostFromAutoKvActionPost(f AutoKvActionPost) ActionPost {
	return ActionPost{autoKvActionPost: &f}
}

// IsAutoKvActionPost checks if the ActionPost is a AutoKvActionPost
func (m ActionPost) IsAutoKvActionPost() bool {
	return m.autoKvActionPost != nil
}

// AutoKvActionPost returns AutoKvActionPost if IsAutoKvActionPost() is true, nil otherwise
func (m ActionPost) AutoKvActionPost() *AutoKvActionPost {
	return m.autoKvActionPost
}

// MakeActionPostFromEvalActionPost creates a new ActionPost from an instance of EvalActionPost
func MakeActionPostFromEvalActionPost(f EvalActionPost) ActionPost {
	return ActionPost{evalActionPost: &f}
}

// IsEvalActionPost checks if the ActionPost is a EvalActionPost
func (m ActionPost) IsEvalActionPost() bool {
	return m.evalActionPost != nil
}

// EvalActionPost returns EvalActionPost if IsEvalActionPost() is true, nil otherwise
func (m ActionPost) EvalActionPost() *EvalActionPost {
	return m.evalActionPost
}

// MakeActionPostFromLookupActionPost creates a new ActionPost from an instance of LookupActionPost
func MakeActionPostFromLookupActionPost(f LookupActionPost) ActionPost {
	return ActionPost{lookupActionPost: &f}
}

// IsLookupActionPost checks if the ActionPost is a LookupActionPost
func (m ActionPost) IsLookupActionPost() bool {
	return m.lookupActionPost != nil
}

// LookupActionPost returns LookupActionPost if IsLookupActionPost() is true, nil otherwise
func (m ActionPost) LookupActionPost() *LookupActionPost {
	return m.lookupActionPost
}

// MakeActionPostFromRegexActionPost creates a new ActionPost from an instance of RegexActionPost
func MakeActionPostFromRegexActionPost(f RegexActionPost) ActionPost {
	return ActionPost{regexActionPost: &f}
}

// IsRegexActionPost checks if the ActionPost is a RegexActionPost
func (m ActionPost) IsRegexActionPost() bool {
	return m.regexActionPost != nil
}

// RegexActionPost returns RegexActionPost if IsRegexActionPost() is true, nil otherwise
func (m ActionPost) RegexActionPost() *RegexActionPost {
	return m.regexActionPost
}

// MakeActionPostFromRawInterface creates a new ActionPost from a raw interface{}
func MakeActionPostFromRawInterface(f interface{}) ActionPost {
	return ActionPost{raw: f}
}

// IsRawInterface checks if the ActionPost is an interface{} (unknown type)
func (m ActionPost) IsRawInterface() bool {
	return m.raw != nil
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m ActionPost) RawInterface() interface{} {
	return m.raw
}

// UnmarshalJSON unmarshals ActionPost using the "kind" property
func (m *ActionPost) UnmarshalJSON(b []byte) (err error) {
	type discriminator struct {
		Kind string `json:"kind"`
	}
	var d discriminator
	err = json.Unmarshal(b, &d)
	if err != nil {
		return err
	}
	// Resolve into respective struct based on the discriminator value
	switch d.Kind {
	case "ALIAS":
		m.aliasActionPost = &AliasActionPost{}
		return json.Unmarshal(b, m.aliasActionPost)
	case "AUTOKV":
		m.autoKvActionPost = &AutoKvActionPost{}
		return json.Unmarshal(b, m.autoKvActionPost)
	case "EVAL":
		m.evalActionPost = &EvalActionPost{}
		return json.Unmarshal(b, m.evalActionPost)
	case "LOOKUP":
		m.lookupActionPost = &LookupActionPost{}
		return json.Unmarshal(b, m.lookupActionPost)
	case "REGEX":
		m.regexActionPost = &RegexActionPost{}
		return json.Unmarshal(b, m.regexActionPost)
	}
	// Unknown discriminator value (this type may not yet be supported)
	// unmarhsal to raw interface
	var raw interface{}
	err = json.Unmarshal(b, &raw)
	if err != nil {
		return err
	}
	m.raw = raw
	return nil
}

// MarshalJSON marshals ActionPost using the appropriate struct field
func (m ActionPost) MarshalJSON() ([]byte, error) {
	if m.IsAliasActionPost() {
		return json.Marshal(m.aliasActionPost)
	} else if m.IsAutoKvActionPost() {
		return json.Marshal(m.autoKvActionPost)
	} else if m.IsEvalActionPost() {
		return json.Marshal(m.evalActionPost)
	} else if m.IsLookupActionPost() {
		return json.Marshal(m.lookupActionPost)
	} else if m.IsRegexActionPost() {
		return json.Marshal(m.regexActionPost)
	}
	// None of the structs are populated, send raw
	return json.Marshal(m.raw)
}

// A complete alias action as rendered in POST, PATCH, and GET responses.
type AliasAction struct {
	// The alias name.
	Alias string `json:"alias"`
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// The name of the field to be aliased.
	Field string `json:"field"`
	// A unique action ID.
	Id   string          `json:"id"`
	Kind AliasActionKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The rule that this action is part of.
	Ruleid string `json:"ruleid"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// AliasActionKind : The alias action kind.
type AliasActionKind string

// List of AliasActionKind
const (
	AliasActionKindAlias AliasActionKind = "ALIAS"
)

// Property values for setting existing alias actions using a PATCH request.
type AliasActionPatch struct {
	// The alias name.
	Alias *string `json:"alias,omitempty"`
	// The name of the field to be aliased.
	Field *string          `json:"field,omitempty"`
	Kind  *AliasActionKind `json:"kind,omitempty"`
	// The name of the user who owns this action. This value is obtained from the bearer token if not present.
	Owner *string `json:"owner,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Initial property values for creating a new alias action using a POST request.
type AliasActionPost struct {
	// The alias name.
	Alias string `json:"alias"`
	// The name of the field to be aliased.
	Field string          `json:"field"`
	Kind  AliasActionKind `json:"kind"`
	// A unique action ID.
	Id *string `json:"id,omitempty"`
	// The rule that this action is part of.
	Ruleid *string `json:"ruleid,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Properties of alias actions which may be read, set, and changed through the API. Implementation detail of ActionPOST, ActionPOST, and Action, do not use directly.
type AliasActionProperties struct {
	// The alias name.
	Alias *string `json:"alias,omitempty"`
	// The name of the field to be aliased.
	Field *string          `json:"field,omitempty"`
	Kind  *AliasActionKind `json:"kind,omitempty"`
}

type Annotation map[string]interface{}

type AnnotationPost map[string]interface{}

// The resource name of an AnnotationType. For the default module, the resource name format is annotationTypeName. Otherwise, the resource name format is module.annotationTypeName.
type AnnotationTypeResourceName string

// Properties of annotations which are read through the API.
type AnnotationsProperties struct {
	// The annotation type ID.
	Annotationtypeid *string `json:"annotationtypeid,omitempty"`
	// The dashboard ID.
	Dashboardid *string `json:"dashboardid,omitempty"`
	// The dataset ID. Null if not annotating a dataset.
	Datasetid *string `json:"datasetid,omitempty"`
	// The field ID. Null if not annotating a field.
	Fieldid *string `json:"fieldid,omitempty"`
	// The relationship ID. Null if not annotating a relationship.
	Relationshipid *string `json:"relationshipid,omitempty"`
}

// Appclientidcreatedby, appclientidmodifiedby app clientid properties for inclusion in othert objects.
type AppClientIdProperties struct {
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
}

// A complete autokv action as rendered in POST, PATCH, and GET responses.
type AutoKvAction struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// A unique action ID.
	Id   string           `json:"id"`
	Kind AutoKvActionKind `json:"kind"`
	// The autokv action mode.
	Mode string `json:"mode"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The rule that this action is part of.
	Ruleid string `json:"ruleid"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// AutoKvActionKind : The autokv action kind.
type AutoKvActionKind string

// List of AutoKVActionKind
const (
	AutoKvActionKindAutokv AutoKvActionKind = "AUTOKV"
)

// Property values for setting existing autokv actions using a PATCH request.
type AutoKvActionPatch struct {
	Kind *AutoKvActionKind `json:"kind,omitempty"`
	// The autokv action mode.
	Mode *string `json:"mode,omitempty"`
	// The name of the user who owns this action. This value is obtained from the bearer token if not present.
	Owner *string `json:"owner,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Initial property values for creating a new autokv action using a POST request.
type AutoKvActionPost struct {
	Kind AutoKvActionKind `json:"kind"`
	// The autokv action mode.
	Mode string `json:"mode"`
	// A unique action ID.
	Id *string `json:"id,omitempty"`
	// The rule that this action is part of.
	Ruleid *string `json:"ruleid,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Properties of auto kv actions which may be read, set, and changed through the API. Implementation detail of ActionPOST, ActionPOST, and Action, do not use directly.
type AutoKvActionProperties struct {
	Kind *AutoKvActionKind `json:"kind,omitempty"`
	// The autokv action mode.
	Mode *string `json:"mode,omitempty"`
}

// A complete catalog dataset as rendered in POST, PATCH, and GET responses.
type CatalogDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// A unique dataset ID.
	Id   string             `json:"id"`
	Kind CatalogDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// Internal use only.
	Url *string `json:"url,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// CatalogDatasetKind : The dataset kind.
type CatalogDatasetKind string

// List of CatalogDatasetKind
const (
	CatalogDatasetKindCatalog CatalogDatasetKind = "catalog"
)

// Properties of catalog datasets which can be read, set, and changed through the API.
type CatalogDatasetProperties struct {
	Kind *CatalogDatasetKind `json:"kind,omitempty"`
	// Internal use only.
	Url *string `json:"url,omitempty"`
}

// A complete dashboard as rendered in POST, PATCH, and GET responses.
type Dashboard struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// The JSON dashboard definition.
	Definition string `json:"definition"`
	// A unique dashboard ID. Random ID used if not provided.
	Id string `json:"id"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The module that contains the dashboard.
	Module string `json:"module"`
	// The dashboard name. Dashboard names must be unique within each tenant.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Whether the dashboard is active or not.
	Isactive *bool `json:"isactive,omitempty"`
	// The version of the dashboard.
	Version *int32 `json:"version,omitempty"`
}

// A list of the mutable dashboard fields.
type DashboardMutable struct {
	// The JSON dashboard definition.
	Definition *string `json:"definition,omitempty"`
	// Whether the dashboard is active or not.
	Isactive *bool `json:"isactive,omitempty"`
	// The module that contains the dashboard.
	Module *string `json:"module,omitempty"`
	// The dashboard name. Dashboard names must be unique within each tenant.
	Name *string `json:"name,omitempty"`
	// The version of the dashboard.
	Version *int32 `json:"version,omitempty"`
}

// Values for updating a dashboard using a PATCH request.
type DashboardPatch struct {
	// The JSON dashboard definition.
	Definition *string `json:"definition,omitempty"`
	// Whether the dashboard is active or not.
	Isactive *bool `json:"isactive,omitempty"`
	// The module that contains the dashboard.
	Module *string `json:"module,omitempty"`
	// The dashboard name. Dashboard names must be unique within each tenant.
	Name *string `json:"name,omitempty"`
	// The version of the dashboard.
	Version *int32 `json:"version,omitempty"`
}

// Initial values for creating a new dashboard using a POST request.
type DashboardPost struct {
	// The JSON dashboard definition.
	Definition string `json:"definition"`
	// The module that contains the dashboard.
	Module string `json:"module"`
	// The dashboard name. Dashboard names must be unique within each tenant.
	Name string `json:"name"`
	// A unique dashboard ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// Whether the dashboard is active or not.
	Isactive *bool `json:"isactive,omitempty"`
	// The version of the dashboard.
	Version *int32 `json:"version,omitempty"`
}

// Dataset : A complete dataset as rendered in POST, PATCH responses.
type Dataset struct {
	federatedDataset    *FederatedDataset
	importDataset       *ImportDataset
	indexDataset        *IndexDataset
	kvCollectionDataset *KvCollectionDataset
	lookupDataset       *LookupDataset
	metricDataset       *MetricDataset
	viewDataset         *ViewDataset
	raw                 interface{}
}

// MakeDatasetFromFederatedDataset creates a new Dataset from an instance of FederatedDataset
func MakeDatasetFromFederatedDataset(f FederatedDataset) Dataset {
	return Dataset{federatedDataset: &f}
}

// IsFederatedDataset checks if the Dataset is a FederatedDataset
func (m Dataset) IsFederatedDataset() bool {
	return m.federatedDataset != nil
}

// FederatedDataset returns FederatedDataset if IsFederatedDataset() is true, nil otherwise
func (m Dataset) FederatedDataset() *FederatedDataset {
	return m.federatedDataset
}

// MakeDatasetFromImportDataset creates a new Dataset from an instance of ImportDataset
func MakeDatasetFromImportDataset(f ImportDataset) Dataset {
	return Dataset{importDataset: &f}
}

// IsImportDataset checks if the Dataset is a ImportDataset
func (m Dataset) IsImportDataset() bool {
	return m.importDataset != nil
}

// ImportDataset returns ImportDataset if IsImportDataset() is true, nil otherwise
func (m Dataset) ImportDataset() *ImportDataset {
	return m.importDataset
}

// MakeDatasetFromIndexDataset creates a new Dataset from an instance of IndexDataset
func MakeDatasetFromIndexDataset(f IndexDataset) Dataset {
	return Dataset{indexDataset: &f}
}

// IsIndexDataset checks if the Dataset is a IndexDataset
func (m Dataset) IsIndexDataset() bool {
	return m.indexDataset != nil
}

// IndexDataset returns IndexDataset if IsIndexDataset() is true, nil otherwise
func (m Dataset) IndexDataset() *IndexDataset {
	return m.indexDataset
}

// MakeDatasetFromKvCollectionDataset creates a new Dataset from an instance of KvCollectionDataset
func MakeDatasetFromKvCollectionDataset(f KvCollectionDataset) Dataset {
	return Dataset{kvCollectionDataset: &f}
}

// IsKvCollectionDataset checks if the Dataset is a KvCollectionDataset
func (m Dataset) IsKvCollectionDataset() bool {
	return m.kvCollectionDataset != nil
}

// KvCollectionDataset returns KvCollectionDataset if IsKvCollectionDataset() is true, nil otherwise
func (m Dataset) KvCollectionDataset() *KvCollectionDataset {
	return m.kvCollectionDataset
}

// MakeDatasetFromLookupDataset creates a new Dataset from an instance of LookupDataset
func MakeDatasetFromLookupDataset(f LookupDataset) Dataset {
	return Dataset{lookupDataset: &f}
}

// IsLookupDataset checks if the Dataset is a LookupDataset
func (m Dataset) IsLookupDataset() bool {
	return m.lookupDataset != nil
}

// LookupDataset returns LookupDataset if IsLookupDataset() is true, nil otherwise
func (m Dataset) LookupDataset() *LookupDataset {
	return m.lookupDataset
}

// MakeDatasetFromMetricDataset creates a new Dataset from an instance of MetricDataset
func MakeDatasetFromMetricDataset(f MetricDataset) Dataset {
	return Dataset{metricDataset: &f}
}

// IsMetricDataset checks if the Dataset is a MetricDataset
func (m Dataset) IsMetricDataset() bool {
	return m.metricDataset != nil
}

// MetricDataset returns MetricDataset if IsMetricDataset() is true, nil otherwise
func (m Dataset) MetricDataset() *MetricDataset {
	return m.metricDataset
}

// MakeDatasetFromViewDataset creates a new Dataset from an instance of ViewDataset
func MakeDatasetFromViewDataset(f ViewDataset) Dataset {
	return Dataset{viewDataset: &f}
}

// IsViewDataset checks if the Dataset is a ViewDataset
func (m Dataset) IsViewDataset() bool {
	return m.viewDataset != nil
}

// ViewDataset returns ViewDataset if IsViewDataset() is true, nil otherwise
func (m Dataset) ViewDataset() *ViewDataset {
	return m.viewDataset
}

// MakeDatasetFromRawInterface creates a new Dataset from a raw interface{}
func MakeDatasetFromRawInterface(f interface{}) Dataset {
	return Dataset{raw: f}
}

// IsRawInterface checks if the Dataset is an interface{} (unknown type)
func (m Dataset) IsRawInterface() bool {
	return m.raw != nil
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m Dataset) RawInterface() interface{} {
	return m.raw
}

// UnmarshalJSON unmarshals Dataset using the "kind" property
func (m *Dataset) UnmarshalJSON(b []byte) (err error) {
	type discriminator struct {
		Kind string `json:"kind"`
	}
	var d discriminator
	err = json.Unmarshal(b, &d)
	if err != nil {
		return err
	}
	// Resolve into respective struct based on the discriminator value
	switch d.Kind {
	case "federated":
		m.federatedDataset = &FederatedDataset{}
		return json.Unmarshal(b, m.federatedDataset)
	case "import":
		m.importDataset = &ImportDataset{}
		return json.Unmarshal(b, m.importDataset)
	case "index":
		m.indexDataset = &IndexDataset{}
		return json.Unmarshal(b, m.indexDataset)
	case "kvcollection":
		m.kvCollectionDataset = &KvCollectionDataset{}
		return json.Unmarshal(b, m.kvCollectionDataset)
	case "lookup":
		m.lookupDataset = &LookupDataset{}
		return json.Unmarshal(b, m.lookupDataset)
	case "metric":
		m.metricDataset = &MetricDataset{}
		return json.Unmarshal(b, m.metricDataset)
	case "view":
		m.viewDataset = &ViewDataset{}
		return json.Unmarshal(b, m.viewDataset)
	}
	// Unknown discriminator value (this type may not yet be supported)
	// unmarhsal to raw interface
	var raw interface{}
	err = json.Unmarshal(b, &raw)
	if err != nil {
		return err
	}
	m.raw = raw
	return nil
}

// MarshalJSON marshals Dataset using the appropriate struct field
func (m Dataset) MarshalJSON() ([]byte, error) {
	if m.IsFederatedDataset() {
		return json.Marshal(m.federatedDataset)
	} else if m.IsImportDataset() {
		return json.Marshal(m.importDataset)
	} else if m.IsIndexDataset() {
		return json.Marshal(m.indexDataset)
	} else if m.IsKvCollectionDataset() {
		return json.Marshal(m.kvCollectionDataset)
	} else if m.IsLookupDataset() {
		return json.Marshal(m.lookupDataset)
	} else if m.IsMetricDataset() {
		return json.Marshal(m.metricDataset)
	} else if m.IsViewDataset() {
		return json.Marshal(m.viewDataset)
	}
	// None of the structs are populated, send raw
	return json.Marshal(m.raw)
}

// Properties that are common across all Dataset kinds rendered in POST, PATCH, and GET responses.
type DatasetCommon struct {
	// A unique dataset ID.
	Id string `json:"id"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// DatasetGet : A complete dataset as rendered in GET responses.
type DatasetGet struct {
	catalogDataset      *CatalogDataset
	federatedDataset    *FederatedDataset
	importDataset       *ImportDataset
	indexDataset        *IndexDataset
	jobDatasetGet       *JobDatasetGet
	kvCollectionDataset *KvCollectionDataset
	lookupDataset       *LookupDataset
	metricDataset       *MetricDataset
	splv1sinkDataset    *Splv1sinkDataset
	viewDataset         *ViewDataset
	raw                 interface{}
}

// MakeDatasetGetFromCatalogDataset creates a new DatasetGet from an instance of CatalogDataset
func MakeDatasetGetFromCatalogDataset(f CatalogDataset) DatasetGet {
	return DatasetGet{catalogDataset: &f}
}

// IsCatalogDataset checks if the DatasetGet is a CatalogDataset
func (m DatasetGet) IsCatalogDataset() bool {
	return m.catalogDataset != nil
}

// CatalogDataset returns CatalogDataset if IsCatalogDataset() is true, nil otherwise
func (m DatasetGet) CatalogDataset() *CatalogDataset {
	return m.catalogDataset
}

// MakeDatasetGetFromFederatedDataset creates a new DatasetGet from an instance of FederatedDataset
func MakeDatasetGetFromFederatedDataset(f FederatedDataset) DatasetGet {
	return DatasetGet{federatedDataset: &f}
}

// IsFederatedDataset checks if the DatasetGet is a FederatedDataset
func (m DatasetGet) IsFederatedDataset() bool {
	return m.federatedDataset != nil
}

// FederatedDataset returns FederatedDataset if IsFederatedDataset() is true, nil otherwise
func (m DatasetGet) FederatedDataset() *FederatedDataset {
	return m.federatedDataset
}

// MakeDatasetGetFromImportDataset creates a new DatasetGet from an instance of ImportDataset
func MakeDatasetGetFromImportDataset(f ImportDataset) DatasetGet {
	return DatasetGet{importDataset: &f}
}

// IsImportDataset checks if the DatasetGet is a ImportDataset
func (m DatasetGet) IsImportDataset() bool {
	return m.importDataset != nil
}

// ImportDataset returns ImportDataset if IsImportDataset() is true, nil otherwise
func (m DatasetGet) ImportDataset() *ImportDataset {
	return m.importDataset
}

// MakeDatasetGetFromIndexDataset creates a new DatasetGet from an instance of IndexDataset
func MakeDatasetGetFromIndexDataset(f IndexDataset) DatasetGet {
	return DatasetGet{indexDataset: &f}
}

// IsIndexDataset checks if the DatasetGet is a IndexDataset
func (m DatasetGet) IsIndexDataset() bool {
	return m.indexDataset != nil
}

// IndexDataset returns IndexDataset if IsIndexDataset() is true, nil otherwise
func (m DatasetGet) IndexDataset() *IndexDataset {
	return m.indexDataset
}

// MakeDatasetGetFromJobDatasetGet creates a new DatasetGet from an instance of JobDatasetGet
func MakeDatasetGetFromJobDatasetGet(f JobDatasetGet) DatasetGet {
	return DatasetGet{jobDatasetGet: &f}
}

// IsJobDatasetGet checks if the DatasetGet is a JobDatasetGet
func (m DatasetGet) IsJobDatasetGet() bool {
	return m.jobDatasetGet != nil
}

// JobDatasetGet returns JobDatasetGet if IsJobDatasetGet() is true, nil otherwise
func (m DatasetGet) JobDatasetGet() *JobDatasetGet {
	return m.jobDatasetGet
}

// MakeDatasetGetFromKvCollectionDataset creates a new DatasetGet from an instance of KvCollectionDataset
func MakeDatasetGetFromKvCollectionDataset(f KvCollectionDataset) DatasetGet {
	return DatasetGet{kvCollectionDataset: &f}
}

// IsKvCollectionDataset checks if the DatasetGet is a KvCollectionDataset
func (m DatasetGet) IsKvCollectionDataset() bool {
	return m.kvCollectionDataset != nil
}

// KvCollectionDataset returns KvCollectionDataset if IsKvCollectionDataset() is true, nil otherwise
func (m DatasetGet) KvCollectionDataset() *KvCollectionDataset {
	return m.kvCollectionDataset
}

// MakeDatasetGetFromLookupDataset creates a new DatasetGet from an instance of LookupDataset
func MakeDatasetGetFromLookupDataset(f LookupDataset) DatasetGet {
	return DatasetGet{lookupDataset: &f}
}

// IsLookupDataset checks if the DatasetGet is a LookupDataset
func (m DatasetGet) IsLookupDataset() bool {
	return m.lookupDataset != nil
}

// LookupDataset returns LookupDataset if IsLookupDataset() is true, nil otherwise
func (m DatasetGet) LookupDataset() *LookupDataset {
	return m.lookupDataset
}

// MakeDatasetGetFromMetricDataset creates a new DatasetGet from an instance of MetricDataset
func MakeDatasetGetFromMetricDataset(f MetricDataset) DatasetGet {
	return DatasetGet{metricDataset: &f}
}

// IsMetricDataset checks if the DatasetGet is a MetricDataset
func (m DatasetGet) IsMetricDataset() bool {
	return m.metricDataset != nil
}

// MetricDataset returns MetricDataset if IsMetricDataset() is true, nil otherwise
func (m DatasetGet) MetricDataset() *MetricDataset {
	return m.metricDataset
}

// MakeDatasetGetFromSplv1sinkDataset creates a new DatasetGet from an instance of Splv1sinkDataset
func MakeDatasetGetFromSplv1sinkDataset(f Splv1sinkDataset) DatasetGet {
	return DatasetGet{splv1sinkDataset: &f}
}

// IsSplv1sinkDataset checks if the DatasetGet is a Splv1sinkDataset
func (m DatasetGet) IsSplv1sinkDataset() bool {
	return m.splv1sinkDataset != nil
}

// Splv1sinkDataset returns Splv1sinkDataset if IsSplv1sinkDataset() is true, nil otherwise
func (m DatasetGet) Splv1sinkDataset() *Splv1sinkDataset {
	return m.splv1sinkDataset
}

// MakeDatasetGetFromViewDataset creates a new DatasetGet from an instance of ViewDataset
func MakeDatasetGetFromViewDataset(f ViewDataset) DatasetGet {
	return DatasetGet{viewDataset: &f}
}

// IsViewDataset checks if the DatasetGet is a ViewDataset
func (m DatasetGet) IsViewDataset() bool {
	return m.viewDataset != nil
}

// ViewDataset returns ViewDataset if IsViewDataset() is true, nil otherwise
func (m DatasetGet) ViewDataset() *ViewDataset {
	return m.viewDataset
}

// MakeDatasetGetFromRawInterface creates a new DatasetGet from a raw interface{}
func MakeDatasetGetFromRawInterface(f interface{}) DatasetGet {
	return DatasetGet{raw: f}
}

// IsRawInterface checks if the DatasetGet is an interface{} (unknown type)
func (m DatasetGet) IsRawInterface() bool {
	return m.raw != nil
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m DatasetGet) RawInterface() interface{} {
	return m.raw
}

// UnmarshalJSON unmarshals DatasetGet using the "kind" property
func (m *DatasetGet) UnmarshalJSON(b []byte) (err error) {
	type discriminator struct {
		Kind string `json:"kind"`
	}
	var d discriminator
	err = json.Unmarshal(b, &d)
	if err != nil {
		return err
	}
	// Resolve into respective struct based on the discriminator value
	switch d.Kind {
	case "catalog":
		m.catalogDataset = &CatalogDataset{}
		return json.Unmarshal(b, m.catalogDataset)
	case "federated":
		m.federatedDataset = &FederatedDataset{}
		return json.Unmarshal(b, m.federatedDataset)
	case "import":
		m.importDataset = &ImportDataset{}
		return json.Unmarshal(b, m.importDataset)
	case "index":
		m.indexDataset = &IndexDataset{}
		return json.Unmarshal(b, m.indexDataset)
	case "job":
		m.jobDatasetGet = &JobDatasetGet{}
		return json.Unmarshal(b, m.jobDatasetGet)
	case "kvcollection":
		m.kvCollectionDataset = &KvCollectionDataset{}
		return json.Unmarshal(b, m.kvCollectionDataset)
	case "lookup":
		m.lookupDataset = &LookupDataset{}
		return json.Unmarshal(b, m.lookupDataset)
	case "metric":
		m.metricDataset = &MetricDataset{}
		return json.Unmarshal(b, m.metricDataset)
	case "splv1sink":
		m.splv1sinkDataset = &Splv1sinkDataset{}
		return json.Unmarshal(b, m.splv1sinkDataset)
	case "view":
		m.viewDataset = &ViewDataset{}
		return json.Unmarshal(b, m.viewDataset)
	}
	// Unknown discriminator value (this type may not yet be supported)
	// unmarhsal to raw interface
	var raw interface{}
	err = json.Unmarshal(b, &raw)
	if err != nil {
		return err
	}
	m.raw = raw
	return nil
}

// MarshalJSON marshals DatasetGet using the appropriate struct field
func (m DatasetGet) MarshalJSON() ([]byte, error) {
	if m.IsCatalogDataset() {
		return json.Marshal(m.catalogDataset)
	} else if m.IsFederatedDataset() {
		return json.Marshal(m.federatedDataset)
	} else if m.IsImportDataset() {
		return json.Marshal(m.importDataset)
	} else if m.IsIndexDataset() {
		return json.Marshal(m.indexDataset)
	} else if m.IsJobDatasetGet() {
		return json.Marshal(m.jobDatasetGet)
	} else if m.IsKvCollectionDataset() {
		return json.Marshal(m.kvCollectionDataset)
	} else if m.IsLookupDataset() {
		return json.Marshal(m.lookupDataset)
	} else if m.IsMetricDataset() {
		return json.Marshal(m.metricDataset)
	} else if m.IsSplv1sinkDataset() {
		return json.Marshal(m.splv1sinkDataset)
	} else if m.IsViewDataset() {
		return json.Marshal(m.viewDataset)
	}
	// None of the structs are populated, send raw
	return json.Marshal(m.raw)
}

type DatasetImportedBy struct {
	// The module that is importing the dataset.
	Module string `json:"module"`
	// The dataset owner.
	Owner string `json:"owner"`
	// The dataset name.
	Name *string `json:"name,omitempty"`
}

// DatasetPatch : Property values to be set in an existing dataset using a PATCH request.
// DatasetPatch is FederatedDatasetPatch, ImportDatasetPatch, IndexDatasetPatch, KvCollectionDatasetPatch, LookupDatasetPatch, MetricDatasetPatch, ViewDatasetPatch, (or interface{} if no matches are found)
type DatasetPatch struct {
	datasetPatch interface{}
	isRaw        bool
}

// UnmarshalJSON unmarshals DatasetPatch into FederatedDatasetPatch, ImportDatasetPatch, IndexDatasetPatch, KvCollectionDatasetPatch, LookupDatasetPatch, MetricDatasetPatch, ViewDatasetPatch, or interface{} if no matches are found
func (m *DatasetPatch) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testFederatedDatasetPatch FederatedDatasetPatch
	if err = attempt(&testFederatedDatasetPatch); err == nil {
		m.datasetPatch = testFederatedDatasetPatch
		return nil
	}
	var testImportDatasetPatch ImportDatasetPatch
	if err = attempt(&testImportDatasetPatch); err == nil {
		m.datasetPatch = testImportDatasetPatch
		return nil
	}
	var testIndexDatasetPatch IndexDatasetPatch
	if err = attempt(&testIndexDatasetPatch); err == nil {
		m.datasetPatch = testIndexDatasetPatch
		return nil
	}
	var testKvCollectionDatasetPatch KvCollectionDatasetPatch
	if err = attempt(&testKvCollectionDatasetPatch); err == nil {
		m.datasetPatch = testKvCollectionDatasetPatch
		return nil
	}
	var testLookupDatasetPatch LookupDatasetPatch
	if err = attempt(&testLookupDatasetPatch); err == nil {
		m.datasetPatch = testLookupDatasetPatch
		return nil
	}
	var testMetricDatasetPatch MetricDatasetPatch
	if err = attempt(&testMetricDatasetPatch); err == nil {
		m.datasetPatch = testMetricDatasetPatch
		return nil
	}
	var testViewDatasetPatch ViewDatasetPatch
	if err = attempt(&testViewDatasetPatch); err == nil {
		m.datasetPatch = testViewDatasetPatch
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.datasetPatch = raw
	return nil
}

// MarshalJSON marshals DatasetPatch using DatasetPatch.DatasetPatch
func (m DatasetPatch) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.datasetPatch)
}

// MakeDatasetPatchFromFederatedDatasetPatch creates a new DatasetPatch from an instance of FederatedDatasetPatch
func MakeDatasetPatchFromFederatedDatasetPatch(f FederatedDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsFederatedDatasetPatch checks if the DatasetPatch is a FederatedDatasetPatch
func (m DatasetPatch) IsFederatedDatasetPatch() bool {
	_, ok := m.datasetPatch.(FederatedDatasetPatch)
	return ok
}

// FederatedDatasetPatch returns FederatedDatasetPatch if IsFederatedDatasetPatch() is true, nil otherwise
func (m DatasetPatch) FederatedDatasetPatch() *FederatedDatasetPatch {
	if v, ok := m.datasetPatch.(FederatedDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromImportDatasetPatch creates a new DatasetPatch from an instance of ImportDatasetPatch
func MakeDatasetPatchFromImportDatasetPatch(f ImportDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsImportDatasetPatch checks if the DatasetPatch is a ImportDatasetPatch
func (m DatasetPatch) IsImportDatasetPatch() bool {
	_, ok := m.datasetPatch.(ImportDatasetPatch)
	return ok
}

// ImportDatasetPatch returns ImportDatasetPatch if IsImportDatasetPatch() is true, nil otherwise
func (m DatasetPatch) ImportDatasetPatch() *ImportDatasetPatch {
	if v, ok := m.datasetPatch.(ImportDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromIndexDatasetPatch creates a new DatasetPatch from an instance of IndexDatasetPatch
func MakeDatasetPatchFromIndexDatasetPatch(f IndexDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsIndexDatasetPatch checks if the DatasetPatch is a IndexDatasetPatch
func (m DatasetPatch) IsIndexDatasetPatch() bool {
	_, ok := m.datasetPatch.(IndexDatasetPatch)
	return ok
}

// IndexDatasetPatch returns IndexDatasetPatch if IsIndexDatasetPatch() is true, nil otherwise
func (m DatasetPatch) IndexDatasetPatch() *IndexDatasetPatch {
	if v, ok := m.datasetPatch.(IndexDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromKvCollectionDatasetPatch creates a new DatasetPatch from an instance of KvCollectionDatasetPatch
func MakeDatasetPatchFromKvCollectionDatasetPatch(f KvCollectionDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsKvCollectionDatasetPatch checks if the DatasetPatch is a KvCollectionDatasetPatch
func (m DatasetPatch) IsKvCollectionDatasetPatch() bool {
	_, ok := m.datasetPatch.(KvCollectionDatasetPatch)
	return ok
}

// KvCollectionDatasetPatch returns KvCollectionDatasetPatch if IsKvCollectionDatasetPatch() is true, nil otherwise
func (m DatasetPatch) KvCollectionDatasetPatch() *KvCollectionDatasetPatch {
	if v, ok := m.datasetPatch.(KvCollectionDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromLookupDatasetPatch creates a new DatasetPatch from an instance of LookupDatasetPatch
func MakeDatasetPatchFromLookupDatasetPatch(f LookupDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsLookupDatasetPatch checks if the DatasetPatch is a LookupDatasetPatch
func (m DatasetPatch) IsLookupDatasetPatch() bool {
	_, ok := m.datasetPatch.(LookupDatasetPatch)
	return ok
}

// LookupDatasetPatch returns LookupDatasetPatch if IsLookupDatasetPatch() is true, nil otherwise
func (m DatasetPatch) LookupDatasetPatch() *LookupDatasetPatch {
	if v, ok := m.datasetPatch.(LookupDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromMetricDatasetPatch creates a new DatasetPatch from an instance of MetricDatasetPatch
func MakeDatasetPatchFromMetricDatasetPatch(f MetricDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsMetricDatasetPatch checks if the DatasetPatch is a MetricDatasetPatch
func (m DatasetPatch) IsMetricDatasetPatch() bool {
	_, ok := m.datasetPatch.(MetricDatasetPatch)
	return ok
}

// MetricDatasetPatch returns MetricDatasetPatch if IsMetricDatasetPatch() is true, nil otherwise
func (m DatasetPatch) MetricDatasetPatch() *MetricDatasetPatch {
	if v, ok := m.datasetPatch.(MetricDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromViewDatasetPatch creates a new DatasetPatch from an instance of ViewDatasetPatch
func MakeDatasetPatchFromViewDatasetPatch(f ViewDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsViewDatasetPatch checks if the DatasetPatch is a ViewDatasetPatch
func (m DatasetPatch) IsViewDatasetPatch() bool {
	_, ok := m.datasetPatch.(ViewDatasetPatch)
	return ok
}

// ViewDatasetPatch returns ViewDatasetPatch if IsViewDatasetPatch() is true, nil otherwise
func (m DatasetPatch) ViewDatasetPatch() *ViewDatasetPatch {
	if v, ok := m.datasetPatch.(ViewDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromRawInterface creates a new DatasetPatch from a raw interface{}
func MakeDatasetPatchFromRawInterface(f interface{}) DatasetPatch {
	return DatasetPatch{
		datasetPatch: f,
		isRaw:        true,
	}
}

// IsRawInterface checks if the DatasetPatch is an interface{} (unknown type)
func (m DatasetPatch) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m DatasetPatch) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.datasetPatch
}

// Properties that are common across all Dataset kinds to be set in an existing dataset using a PATCH request.
type DatasetPatchCommon struct {
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// DatasetPost : Initial property values for creating a new action using a POST request.
type DatasetPost struct {
	federatedDatasetPost    *FederatedDatasetPost
	importDatasetPost       *ImportDatasetPost
	indexDatasetPost        *IndexDatasetPost
	kvCollectionDatasetPost *KvCollectionDatasetPost
	lookupDatasetPost       *LookupDatasetPost
	metricDatasetPost       *MetricDatasetPost
	viewDatasetPost         *ViewDatasetPost
	raw                     interface{}
}

// MakeDatasetPostFromFederatedDatasetPost creates a new DatasetPost from an instance of FederatedDatasetPost
func MakeDatasetPostFromFederatedDatasetPost(f FederatedDatasetPost) DatasetPost {
	return DatasetPost{federatedDatasetPost: &f}
}

// IsFederatedDatasetPost checks if the DatasetPost is a FederatedDatasetPost
func (m DatasetPost) IsFederatedDatasetPost() bool {
	return m.federatedDatasetPost != nil
}

// FederatedDatasetPost returns FederatedDatasetPost if IsFederatedDatasetPost() is true, nil otherwise
func (m DatasetPost) FederatedDatasetPost() *FederatedDatasetPost {
	return m.federatedDatasetPost
}

// MakeDatasetPostFromImportDatasetPost creates a new DatasetPost from an instance of ImportDatasetPost
func MakeDatasetPostFromImportDatasetPost(f ImportDatasetPost) DatasetPost {
	return DatasetPost{importDatasetPost: &f}
}

// IsImportDatasetPost checks if the DatasetPost is a ImportDatasetPost
func (m DatasetPost) IsImportDatasetPost() bool {
	return m.importDatasetPost != nil
}

// ImportDatasetPost returns ImportDatasetPost if IsImportDatasetPost() is true, nil otherwise
func (m DatasetPost) ImportDatasetPost() *ImportDatasetPost {
	return m.importDatasetPost
}

// MakeDatasetPostFromIndexDatasetPost creates a new DatasetPost from an instance of IndexDatasetPost
func MakeDatasetPostFromIndexDatasetPost(f IndexDatasetPost) DatasetPost {
	return DatasetPost{indexDatasetPost: &f}
}

// IsIndexDatasetPost checks if the DatasetPost is a IndexDatasetPost
func (m DatasetPost) IsIndexDatasetPost() bool {
	return m.indexDatasetPost != nil
}

// IndexDatasetPost returns IndexDatasetPost if IsIndexDatasetPost() is true, nil otherwise
func (m DatasetPost) IndexDatasetPost() *IndexDatasetPost {
	return m.indexDatasetPost
}

// MakeDatasetPostFromKvCollectionDatasetPost creates a new DatasetPost from an instance of KvCollectionDatasetPost
func MakeDatasetPostFromKvCollectionDatasetPost(f KvCollectionDatasetPost) DatasetPost {
	return DatasetPost{kvCollectionDatasetPost: &f}
}

// IsKvCollectionDatasetPost checks if the DatasetPost is a KvCollectionDatasetPost
func (m DatasetPost) IsKvCollectionDatasetPost() bool {
	return m.kvCollectionDatasetPost != nil
}

// KvCollectionDatasetPost returns KvCollectionDatasetPost if IsKvCollectionDatasetPost() is true, nil otherwise
func (m DatasetPost) KvCollectionDatasetPost() *KvCollectionDatasetPost {
	return m.kvCollectionDatasetPost
}

// MakeDatasetPostFromLookupDatasetPost creates a new DatasetPost from an instance of LookupDatasetPost
func MakeDatasetPostFromLookupDatasetPost(f LookupDatasetPost) DatasetPost {
	return DatasetPost{lookupDatasetPost: &f}
}

// IsLookupDatasetPost checks if the DatasetPost is a LookupDatasetPost
func (m DatasetPost) IsLookupDatasetPost() bool {
	return m.lookupDatasetPost != nil
}

// LookupDatasetPost returns LookupDatasetPost if IsLookupDatasetPost() is true, nil otherwise
func (m DatasetPost) LookupDatasetPost() *LookupDatasetPost {
	return m.lookupDatasetPost
}

// MakeDatasetPostFromMetricDatasetPost creates a new DatasetPost from an instance of MetricDatasetPost
func MakeDatasetPostFromMetricDatasetPost(f MetricDatasetPost) DatasetPost {
	return DatasetPost{metricDatasetPost: &f}
}

// IsMetricDatasetPost checks if the DatasetPost is a MetricDatasetPost
func (m DatasetPost) IsMetricDatasetPost() bool {
	return m.metricDatasetPost != nil
}

// MetricDatasetPost returns MetricDatasetPost if IsMetricDatasetPost() is true, nil otherwise
func (m DatasetPost) MetricDatasetPost() *MetricDatasetPost {
	return m.metricDatasetPost
}

// MakeDatasetPostFromViewDatasetPost creates a new DatasetPost from an instance of ViewDatasetPost
func MakeDatasetPostFromViewDatasetPost(f ViewDatasetPost) DatasetPost {
	return DatasetPost{viewDatasetPost: &f}
}

// IsViewDatasetPost checks if the DatasetPost is a ViewDatasetPost
func (m DatasetPost) IsViewDatasetPost() bool {
	return m.viewDatasetPost != nil
}

// ViewDatasetPost returns ViewDatasetPost if IsViewDatasetPost() is true, nil otherwise
func (m DatasetPost) ViewDatasetPost() *ViewDatasetPost {
	return m.viewDatasetPost
}

// MakeDatasetPostFromRawInterface creates a new DatasetPost from a raw interface{}
func MakeDatasetPostFromRawInterface(f interface{}) DatasetPost {
	return DatasetPost{raw: f}
}

// IsRawInterface checks if the DatasetPost is an interface{} (unknown type)
func (m DatasetPost) IsRawInterface() bool {
	return m.raw != nil
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m DatasetPost) RawInterface() interface{} {
	return m.raw
}

// UnmarshalJSON unmarshals DatasetPost using the "kind" property
func (m *DatasetPost) UnmarshalJSON(b []byte) (err error) {
	type discriminator struct {
		Kind string `json:"kind"`
	}
	var d discriminator
	err = json.Unmarshal(b, &d)
	if err != nil {
		return err
	}
	// Resolve into respective struct based on the discriminator value
	switch d.Kind {
	case "federated":
		m.federatedDatasetPost = &FederatedDatasetPost{}
		return json.Unmarshal(b, m.federatedDatasetPost)
	case "import":
		m.importDatasetPost = &ImportDatasetPost{}
		return json.Unmarshal(b, m.importDatasetPost)
	case "index":
		m.indexDatasetPost = &IndexDatasetPost{}
		return json.Unmarshal(b, m.indexDatasetPost)
	case "kvcollection":
		m.kvCollectionDatasetPost = &KvCollectionDatasetPost{}
		return json.Unmarshal(b, m.kvCollectionDatasetPost)
	case "lookup":
		m.lookupDatasetPost = &LookupDatasetPost{}
		return json.Unmarshal(b, m.lookupDatasetPost)
	case "metric":
		m.metricDatasetPost = &MetricDatasetPost{}
		return json.Unmarshal(b, m.metricDatasetPost)
	case "view":
		m.viewDatasetPost = &ViewDatasetPost{}
		return json.Unmarshal(b, m.viewDatasetPost)
	}
	// Unknown discriminator value (this type may not yet be supported)
	// unmarhsal to raw interface
	var raw interface{}
	err = json.Unmarshal(b, &raw)
	if err != nil {
		return err
	}
	m.raw = raw
	return nil
}

// MarshalJSON marshals DatasetPost using the appropriate struct field
func (m DatasetPost) MarshalJSON() ([]byte, error) {
	if m.IsFederatedDatasetPost() {
		return json.Marshal(m.federatedDatasetPost)
	} else if m.IsImportDatasetPost() {
		return json.Marshal(m.importDatasetPost)
	} else if m.IsIndexDatasetPost() {
		return json.Marshal(m.indexDatasetPost)
	} else if m.IsKvCollectionDatasetPost() {
		return json.Marshal(m.kvCollectionDatasetPost)
	} else if m.IsLookupDatasetPost() {
		return json.Marshal(m.lookupDatasetPost)
	} else if m.IsMetricDatasetPost() {
		return json.Marshal(m.metricDatasetPost)
	} else if m.IsViewDatasetPost() {
		return json.Marshal(m.viewDatasetPost)
	}
	// None of the structs are populated, send raw
	return json.Marshal(m.raw)
}

// Properties that are common across all Dataset kinds for creating a new dataset using a POST request.
type DatasetPostCommon struct {
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Created and Modified date-time properties for inclusion in other objects.
type DateMetadataProperties struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The date and time object was modified.
	Modified string `json:"modified"`
}

// A complete eval action as rendered in POST, PATCH, and GET responses.
type EvalAction struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// The EVAL expression that calculates the field.
	Expression string `json:"expression"`
	// The name of the field that is added or modified by the EVAL expression.
	Field string `json:"field"`
	// A unique action ID.
	Id   string         `json:"id"`
	Kind EvalActionKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The rule that this action is part of.
	Ruleid string `json:"ruleid"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// EvalActionKind : The eval action kind.
type EvalActionKind string

// List of EvalActionKind
const (
	EvalActionKindEval EvalActionKind = "EVAL"
)

// Property values for setting existing eval actions using a PATCH request.
type EvalActionPatch struct {
	// The EVAL expression that calculates the field.
	Expression *string `json:"expression,omitempty"`
	// The name of the field that is added or modified by the EVAL expression.
	Field *string         `json:"field,omitempty"`
	Kind  *EvalActionKind `json:"kind,omitempty"`
	// The name of the user who owns this action. This value is obtained from the bearer token if not present.
	Owner *string `json:"owner,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Initial property values for creating a new eval action using a POST request.
type EvalActionPost struct {
	// The EVAL expression that calculates the field.
	Expression string `json:"expression"`
	// The name of the field that is added or modified by the EVAL expression.
	Field string         `json:"field"`
	Kind  EvalActionKind `json:"kind"`
	// A unique action ID.
	Id *string `json:"id,omitempty"`
	// The rule that this action is part of.
	Ruleid *string `json:"ruleid,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Properties of eval actions which may be read, set, and changed through the API. Implementation detail of ActionPOST, ActionPOST, and Action, do not use directly.
type EvalActionProperties struct {
	// The EVAL expression that calculates the field.
	Expression *string `json:"expression,omitempty"`
	// The name of the field that is added or modified by the EVAL expression.
	Field *string         `json:"field,omitempty"`
	Kind  *EvalActionKind `json:"kind,omitempty"`
}

// A complete federated dataset as rendered in POST, PATCH, and GET responses.
type FederatedDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// Connection information to connect to remote federated connection.
	FederatedConnection string `json:"federatedConnection"`
	// Dataset information in the remote instance.
	FederatedDataset string `json:"federatedDataset"`
	// Dataset kind information in the remote instance.
	FederatedDatasetKind string `json:"federatedDatasetKind"`
	// A unique dataset ID.
	Id   string               `json:"id"`
	Kind FederatedDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// FederatedDatasetKind : The dataset kind.
type FederatedDatasetKind string

// List of FederatedDatasetKind
const (
	FederatedDatasetKindFederated FederatedDatasetKind = "federated"
)

// Property values to be set in an existing federated dataset using a PATCH request.
type FederatedDatasetPatch struct {
	// Connection information to connect to remote federated connection.
	FederatedConnection *string `json:"federatedConnection,omitempty"`
	// Dataset information in the remote instance.
	FederatedDataset *string `json:"federatedDataset,omitempty"`
	// Dataset kind information in the remote instance.
	FederatedDatasetKind *string               `json:"federatedDatasetKind,omitempty"`
	Kind                 *FederatedDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Initial property values for creating a new federated dataset using a POST request.
type FederatedDatasetPost struct {
	// Connection information to connect to remote federated connection.
	FederatedConnection string `json:"federatedConnection"`
	// Dataset information in the remote instance.
	FederatedDataset string `json:"federatedDataset"`
	// Dataset kind information in the remote instance.
	FederatedDatasetKind string               `json:"federatedDatasetKind"`
	Kind                 FederatedDatasetKind `json:"kind"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Properties of job datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type FederatedDatasetProperties struct {
	// Connection information to connect to remote federated connection.
	FederatedConnection *string `json:"federatedConnection,omitempty"`
	// Dataset information in the remote instance.
	FederatedDataset *string `json:"federatedDataset,omitempty"`
	// Dataset kind information in the remote instance.
	FederatedDatasetKind *string               `json:"federatedDatasetKind,omitempty"`
	Kind                 *FederatedDatasetKind `json:"kind,omitempty"`
}

// A complete field as rendered in POST, PATCH, and GET responses.
type Field struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The dataset that the field is part of.
	Datasetid string        `json:"datasetid"`
	Datatype  FieldDataType `json:"datatype"`
	Fieldtype FieldType     `json:"fieldtype"`
	// The unique ID of this field.
	Id string `json:"id"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The field name.
	Name       string          `json:"name"`
	Prevalence FieldPrevalence `json:"prevalence"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// The field description.
	Description *string `json:"description,omitempty"`
	// Whether or not the field has been indexed.
	Indexed *bool `json:"indexed,omitempty"`
	// The field summary.
	Summary *string `json:"summary,omitempty"`
	// The field title.
	Title *string `json:"title,omitempty"`
}

// FieldDataType : The type of data in the field. Must be one of the valid values.
type FieldDataType string

// List of FieldDataType
const (
	FieldDataTypeDate     FieldDataType = "DATE"
	FieldDataTypeNumber   FieldDataType = "NUMBER"
	FieldDataTypeObjectId FieldDataType = "OBJECT_ID"
	FieldDataTypeString   FieldDataType = "STRING"
	FieldDataTypeUnknown  FieldDataType = "UNKNOWN"
)

// Property values to be set in an existing field using a PATCH request.
type FieldPatch struct {
	Datatype *FieldDataType `json:"datatype,omitempty"`
	// The field description.
	Description *string    `json:"description,omitempty"`
	Fieldtype   *FieldType `json:"fieldtype,omitempty"`
	// Whether or not the field has been indexed.
	Indexed *bool `json:"indexed,omitempty"`
	// The field name.
	Name       *string          `json:"name,omitempty"`
	Prevalence *FieldPrevalence `json:"prevalence,omitempty"`
	// The field summary.
	Summary *string `json:"summary,omitempty"`
	// The field title.
	Title *string `json:"title,omitempty"`
}

// Initial property values for creating a new field using a POST request.
type FieldPost struct {
	// The field name.
	Name     string         `json:"name"`
	Datatype *FieldDataType `json:"datatype,omitempty"`
	// The field description.
	Description *string    `json:"description,omitempty"`
	Fieldtype   *FieldType `json:"fieldtype,omitempty"`
	// Whether or not the field has been indexed.
	Indexed    *bool            `json:"indexed,omitempty"`
	Prevalence *FieldPrevalence `json:"prevalence,omitempty"`
	// The field summary.
	Summary *string `json:"summary,omitempty"`
	// The field title.
	Title *string `json:"title,omitempty"`
}

// FieldPrevalence : How frequent the field appears in the dataset. Must be one of the valid values.
type FieldPrevalence string

// List of FieldPrevalence
const (
	FieldPrevalenceAll     FieldPrevalence = "ALL"
	FieldPrevalenceSome    FieldPrevalence = "SOME"
	FieldPrevalenceUnknown FieldPrevalence = "UNKNOWN"
)

// Properties of fields which can be read, set, and changed through the API. Implementation detail of FieldPOST, FieldPATCH, and Field, do not use directly.
type FieldProperties struct {
	Datatype *FieldDataType `json:"datatype,omitempty"`
	// The field description.
	Description *string    `json:"description,omitempty"`
	Fieldtype   *FieldType `json:"fieldtype,omitempty"`
	// Whether or not the field has been indexed.
	Indexed *bool `json:"indexed,omitempty"`
	// The field name.
	Name       *string          `json:"name,omitempty"`
	Prevalence *FieldPrevalence `json:"prevalence,omitempty"`
	// The field summary.
	Summary *string `json:"summary,omitempty"`
	// The field title.
	Title *string `json:"title,omitempty"`
}

// FieldType : The type of field. Must be one of the valid values.
type FieldType string

// List of FieldType
const (
	FieldTypeDimension FieldType = "DIMENSION"
	FieldTypeMeasure   FieldType = "MEASURE"
	FieldTypeUnknown   FieldType = "UNKNOWN"
)

// A complete import dataset as rendered in POST, PATCH, and GET responses.
type ImportDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// A unique dataset ID.
	Id   string            `json:"id"`
	Kind ImportDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// The dataset module being imported.
	SourceModule string `json:"sourceModule"`
	// The dataset name being imported.
	SourceName string `json:"sourceName"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Initial property values for creating a new import dataset by sourceId using a POST request.
type ImportDatasetByIdPost struct {
	Kind ImportDatasetKind `json:"kind"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The dataset ID being imported.
	SourceId string `json:"sourceId"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Initial property values for creating a new import dataset by sourceId using a POST request.
type ImportDatasetByIdProperties struct {
	Kind *ImportDatasetKind `json:"kind,omitempty"`
	// The dataset ID being imported.
	SourceId *string `json:"sourceId,omitempty"`
}

// Initial property values for creating a new import dataset by sourceName and sourceModule using a POST request.
type ImportDatasetByNamePost struct {
	Kind ImportDatasetKind `json:"kind"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The dataset module being imported.
	SourceModule string `json:"sourceModule"`
	// The dataset name being imported.
	SourceName string `json:"sourceName"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Properties of import datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type ImportDatasetByNameProperties struct {
	Kind *ImportDatasetKind `json:"kind,omitempty"`
	// The dataset module being imported.
	SourceModule *string `json:"sourceModule,omitempty"`
	// The dataset name being imported.
	SourceName *string `json:"sourceName,omitempty"`
}

// ImportDatasetKind : The dataset kind.
type ImportDatasetKind string

// List of ImportDatasetKind
const (
	ImportDatasetKindModelImport ImportDatasetKind = "import"
)

// Property values to be set in an existing import dataset using a PATCH request.
type ImportDatasetPatch struct {
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// ImportDatasetPost : Initial property values for creating a new import dataset using a POST request.
// ImportDatasetPost is ImportDatasetByIdPost, ImportDatasetByNamePost, (or interface{} if no matches are found)
type ImportDatasetPost struct {
	importDatasetPost interface{}
	isRaw             bool
}

// UnmarshalJSON unmarshals ImportDatasetPost into ImportDatasetByIdPost, ImportDatasetByNamePost, or interface{} if no matches are found
func (m *ImportDatasetPost) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testImportDatasetByIdPost ImportDatasetByIdPost
	if err = attempt(&testImportDatasetByIdPost); err == nil {
		m.importDatasetPost = testImportDatasetByIdPost
		return nil
	}
	var testImportDatasetByNamePost ImportDatasetByNamePost
	if err = attempt(&testImportDatasetByNamePost); err == nil {
		m.importDatasetPost = testImportDatasetByNamePost
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.importDatasetPost = raw
	return nil
}

// MarshalJSON marshals ImportDatasetPost using ImportDatasetPost.ImportDatasetPost
func (m ImportDatasetPost) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.importDatasetPost)
}

// MakeImportDatasetPostFromImportDatasetByIdPost creates a new ImportDatasetPost from an instance of ImportDatasetByIdPost
func MakeImportDatasetPostFromImportDatasetByIdPost(f ImportDatasetByIdPost) ImportDatasetPost {
	return ImportDatasetPost{importDatasetPost: f}
}

// IsImportDatasetByIdPost checks if the ImportDatasetPost is a ImportDatasetByIdPost
func (m ImportDatasetPost) IsImportDatasetByIdPost() bool {
	_, ok := m.importDatasetPost.(ImportDatasetByIdPost)
	return ok
}

// ImportDatasetByIdPost returns ImportDatasetByIdPost if IsImportDatasetByIdPost() is true, nil otherwise
func (m ImportDatasetPost) ImportDatasetByIdPost() *ImportDatasetByIdPost {
	if v, ok := m.importDatasetPost.(ImportDatasetByIdPost); ok {
		return &v
	}
	return nil
}

// MakeImportDatasetPostFromImportDatasetByNamePost creates a new ImportDatasetPost from an instance of ImportDatasetByNamePost
func MakeImportDatasetPostFromImportDatasetByNamePost(f ImportDatasetByNamePost) ImportDatasetPost {
	return ImportDatasetPost{importDatasetPost: f}
}

// IsImportDatasetByNamePost checks if the ImportDatasetPost is a ImportDatasetByNamePost
func (m ImportDatasetPost) IsImportDatasetByNamePost() bool {
	_, ok := m.importDatasetPost.(ImportDatasetByNamePost)
	return ok
}

// ImportDatasetByNamePost returns ImportDatasetByNamePost if IsImportDatasetByNamePost() is true, nil otherwise
func (m ImportDatasetPost) ImportDatasetByNamePost() *ImportDatasetByNamePost {
	if v, ok := m.importDatasetPost.(ImportDatasetByNamePost); ok {
		return &v
	}
	return nil
}

// MakeImportDatasetPostFromRawInterface creates a new ImportDatasetPost from a raw interface{}
func MakeImportDatasetPostFromRawInterface(f interface{}) ImportDatasetPost {
	return ImportDatasetPost{
		importDatasetPost: f,
		isRaw:             true,
	}
}

// IsRawInterface checks if the ImportDatasetPost is an interface{} (unknown type)
func (m ImportDatasetPost) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m ImportDatasetPost) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.importDatasetPost
}

// A complete index dataset as rendered in POST, PATCH, and GET responses.
type IndexDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// Specifies whether or not the Splunk index is disabled.
	Disabled bool `json:"disabled"`
	// A unique dataset ID.
	Id   string           `json:"id"`
	Kind IndexDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The timestamp, in seconds, of the earliest event. The timestamp is in UNIX time.
	EarliestEventTime *string `json:"earliestEventTime,omitempty"`
	// The earliest index time for any of the events in this index.
	EarliestIngestTime *string `json:"earliestIngestTime,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32 `json:"frozenTimePeriodInSecs,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// The timestamp, in seconds, of the latest event. The timestamp is in UNIX time.
	LatestEventTime *string `json:"latestEventTime,omitempty"`
	// The latest index time for any of the events in this index.
	LatestIngestTime *string `json:"latestIngestTime,omitempty"`
	// The latest time that the index metadata was refreshed.
	LatestMetadataUpdateTime *string `json:"latestMetadataUpdateTime,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// The number of events in the index.
	TotalEventCount *int64 `json:"totalEventCount,omitempty"`
	// The raw size, in bytes, of the uncompressed data in the indexers.
	TotalSize *int64 `json:"totalSize,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// IndexDatasetKind : The dataset kind.
type IndexDatasetKind string

// List of IndexDatasetKind
const (
	IndexDatasetKindIndex IndexDatasetKind = "index"
)

// Property values to be set in an existing index dataset using a PATCH request.
type IndexDatasetPatch struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32            `json:"frozenTimePeriodInSecs,omitempty"`
	Kind                   *IndexDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Initial property values for creating a new index dataset using a POST request.
type IndexDatasetPost struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled bool             `json:"disabled"`
	Kind     IndexDatasetKind `json:"kind"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32 `json:"frozenTimePeriodInSecs,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Properties of job datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type IndexDatasetProperties struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32            `json:"frozenTimePeriodInSecs,omitempty"`
	Kind                   *IndexDatasetKind `json:"kind,omitempty"`
}

// Properties of index datasets which can only be read through the API.
type IndexDatasetReadOnlyProperties struct {
	// The timestamp, in seconds, of the earliest event. The timestamp is in UNIX time.
	EarliestEventTime *string `json:"earliestEventTime,omitempty"`
	// The earliest index time for any of the events in this index.
	EarliestIngestTime *string           `json:"earliestIngestTime,omitempty"`
	Kind               *IndexDatasetKind `json:"kind,omitempty"`
	// The timestamp, in seconds, of the latest event. The timestamp is in UNIX time.
	LatestEventTime *string `json:"latestEventTime,omitempty"`
	// The latest index time for any of the events in this index.
	LatestIngestTime *string `json:"latestIngestTime,omitempty"`
	// The latest time that the index metadata was refreshed.
	LatestMetadataUpdateTime *string `json:"latestMetadataUpdateTime,omitempty"`
	// The number of events in the index.
	TotalEventCount *int64 `json:"totalEventCount,omitempty"`
	// The raw size, in bytes, of the uncompressed data in the indexers.
	TotalSize *int64 `json:"totalSize,omitempty"`
}

// JobDatasetEventSummaryAvailableStatus : Availability of event summary.
type JobDatasetEventSummaryAvailableStatus string

// List of JobDatasetEventSummaryAvailableStatus
const (
	JobDatasetEventSummaryAvailableStatusTrue    JobDatasetEventSummaryAvailableStatus = "true"
	JobDatasetEventSummaryAvailableStatusFalse   JobDatasetEventSummaryAvailableStatus = "false"
	JobDatasetEventSummaryAvailableStatusUnknown JobDatasetEventSummaryAvailableStatus = "UNKNOWN"
)

// JobDatasetFieldSummaryAvailableStatus : Availability of field summary.
type JobDatasetFieldSummaryAvailableStatus string

// List of JobDatasetFieldSummaryAvailableStatus
const (
	JobDatasetFieldSummaryAvailableStatusTrue    JobDatasetFieldSummaryAvailableStatus = "true"
	JobDatasetFieldSummaryAvailableStatusFalse   JobDatasetFieldSummaryAvailableStatus = "false"
	JobDatasetFieldSummaryAvailableStatusUnknown JobDatasetFieldSummaryAvailableStatus = "UNKNOWN"
)

// Job dataset as rendered in POST response for dataset API endpoint.
type JobDatasetGet struct {
	// Time that the job was completed
	CompletionTime string `json:"completionTime"`
	// The time the dataset will be available in S3.
	DeleteTime string `json:"deleteTime"`
	// Time that the job was dispatched
	DispatchTime string         `json:"dispatchTime"`
	Kind         JobDatasetKind `json:"kind"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// Parameters for the search job, mainly earliest, latest, timezone, and relativeTimeAnchor.
	Parameters map[string]interface{} `json:"parameters"`
	// The SPL query string for the search job.
	Query string `json:"query"`
	// Resolved earliest time for the job
	ResolvedEarliest string `json:"resolvedEarliest"`
	// Resolved latest time for the job
	ResolvedLatest string `json:"resolvedLatest"`
	// The ID assigned to the search job.
	Sid string `json:"sid"`
	// Was the event summary requested for this searhc job?
	CollectEventSummary *bool `json:"collectEventSummary,omitempty"`
	// Was the field summary requested for this searhc job?
	CollectFieldSummary *bool `json:"collectFieldSummary,omitempty"`
	// Were the time bucketes requested for this searhc job?
	CollectTimeBuckets *bool `json:"collectTimeBuckets,omitempty"`
	// Specifies whether a search is allowed to collect preview results during the runtime, internal search service use only.
	EnablePreview *bool `json:"enablePreview,omitempty"`
	// The runtime of the search in seconds.
	ExecutionTime *float32 `json:"executionTime,omitempty"`
	// Should the search produce all fields (including those not explicity mentioned in the SPL)?
	ExtractAllFields *bool `json:"extractAllFields,omitempty"`
	// The fields to extract. Valid values are all, none, or indexed.
	ExtractFields *string `json:"extractFields,omitempty"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// Did the SPL query cause any side effects on a dataset?
	HasSideEffects *bool `json:"hasSideEffects,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The maximum number of seconds to run this search before finishing.
	MaxTime *int32 `json:"maxTime,omitempty"`
	// Array of json objects to store critical search job messages.
	Messages []map[string]interface{} `json:"messages,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
	// The parent's ID of the search job.
	Parent *string `json:"parent,omitempty"`
	// An estimate of how complete the search job is.
	PercentComplete *int32 `json:"percentComplete,omitempty"`
	// The instantaneous number of results produced by the search job.
	ResultsAvailable *int32 `json:"resultsAvailable,omitempty"`
	// The search head that started this search job.
	SearchHead *string `json:"searchHead,omitempty"`
	// The SPLv2 version of the search job query string.
	Spl *string `json:"spl,omitempty"`
	// The current status of the search job.
	Status           *string                               `json:"status,omitempty"`
	TimelineMetadata *JobDatasetPropertiesTimelineMetadata `json:"timelineMetadata,omitempty"`
}

// JobDatasetKind : The dataset kind.
type JobDatasetKind string

// List of JobDatasetKind
const (
	JobDatasetKindJob JobDatasetKind = "job"
)

// Properties of job datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type JobDatasetProperties struct {
	// Was the event summary requested for this searhc job?
	CollectEventSummary *bool `json:"collectEventSummary,omitempty"`
	// Was the field summary requested for this searhc job?
	CollectFieldSummary *bool `json:"collectFieldSummary,omitempty"`
	// Were the time bucketes requested for this searhc job?
	CollectTimeBuckets *bool `json:"collectTimeBuckets,omitempty"`
	// Time that the job was completed
	CompletionTime *string `json:"completionTime,omitempty"`
	// The time the dataset will be available in S3.
	DeleteTime *string `json:"deleteTime,omitempty"`
	// Time that the job was dispatched
	DispatchTime *string `json:"dispatchTime,omitempty"`
	// Specifies whether a search is allowed to collect preview results during the runtime, internal search service use only.
	EnablePreview *bool `json:"enablePreview,omitempty"`
	// The runtime of the search in seconds.
	ExecutionTime *float32 `json:"executionTime,omitempty"`
	// Should the search produce all fields (including those not explicity mentioned in the SPL)?
	ExtractAllFields *bool `json:"extractAllFields,omitempty"`
	// The fields to extract. Valid values are all, none, or indexed.
	ExtractFields *string `json:"extractFields,omitempty"`
	// Did the SPL query cause any side effects on a dataset?
	HasSideEffects *bool           `json:"hasSideEffects,omitempty"`
	Kind           *JobDatasetKind `json:"kind,omitempty"`
	// The maximum number of seconds to run this search before finishing.
	MaxTime *int32 `json:"maxTime,omitempty"`
	// Array of json objects to store critical search job messages.
	Messages []map[string]interface{} `json:"messages,omitempty"`
	// Parameters for the search job, mainly earliest, latest, timezone, and relativeTimeAnchor.
	Parameters map[string]interface{} `json:"parameters,omitempty"`
	// The parent's ID of the search job.
	Parent *string `json:"parent,omitempty"`
	// An estimate of how complete the search job is.
	PercentComplete *int32 `json:"percentComplete,omitempty"`
	// The SPL query string for the search job.
	Query *string `json:"query,omitempty"`
	// Resolved earliest time for the job
	ResolvedEarliest *string `json:"resolvedEarliest,omitempty"`
	// Resolved latest time for the job
	ResolvedLatest *string `json:"resolvedLatest,omitempty"`
	// The instantaneous number of results produced by the search job.
	ResultsAvailable *int32 `json:"resultsAvailable,omitempty"`
	// The search head that started this search job.
	SearchHead *string `json:"searchHead,omitempty"`
	// The ID assigned to the search job.
	Sid *string `json:"sid,omitempty"`
	// The SPLv2 version of the search job query string.
	Spl *string `json:"spl,omitempty"`
	// The current status of the search job.
	Status           *string                               `json:"status,omitempty"`
	TimelineMetadata *JobDatasetPropertiesTimelineMetadata `json:"timelineMetadata,omitempty"`
}

// Availability of timeline metadata artifacts.
type JobDatasetPropertiesTimelineMetadata struct {
	Auto *JobDatasetPropertiesTimelineMetadataAuto `json:"auto,omitempty"`
}

// Availability of automatic timeline metadata artifacts.
type JobDatasetPropertiesTimelineMetadataAuto struct {
	EventSummaryAvailable *JobDatasetEventSummaryAvailableStatus `json:"eventSummaryAvailable,omitempty"`
	FieldSummaryAvailable *JobDatasetFieldSummaryAvailableStatus `json:"fieldSummaryAvailable,omitempty"`
	TimeBucketsAvailable  *JobDatasetTimeBucketsAvailableStatus  `json:"timeBucketsAvailable,omitempty"`
}

// JobDatasetTimeBucketsAvailableStatus : Availability of time buckets (histogram of events).
type JobDatasetTimeBucketsAvailableStatus string

// List of JobDatasetTimeBucketsAvailableStatus
const (
	JobDatasetTimeBucketsAvailableStatusTrue    JobDatasetTimeBucketsAvailableStatus = "true"
	JobDatasetTimeBucketsAvailableStatusFalse   JobDatasetTimeBucketsAvailableStatus = "false"
	JobDatasetTimeBucketsAvailableStatusUnknown JobDatasetTimeBucketsAvailableStatus = "UNKNOWN"
)

// A complete kvcollection dataset as rendered in POST, PATCH, and GET responses.
type KvCollectionDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// A unique dataset ID.
	Id   string                  `json:"id"`
	Kind KvCollectionDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// KvCollectionDatasetKind : The dataset kind.
type KvCollectionDatasetKind string

// List of KVCollectionDatasetKind
const (
	KvCollectionDatasetKindKvcollection KvCollectionDatasetKind = "kvcollection"
)

// Property values to be set in an existing kvcollection dataset using a PATCH request.
type KvCollectionDatasetPatch struct {
	Kind *KvCollectionDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Initial property values for creating a new kvcollection dataset using a POST request.
type KvCollectionDatasetPost struct {
	Kind KvCollectionDatasetKind `json:"kind"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Properties of kvcollection datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type KvCollectionDatasetProperties struct {
	Kind *KvCollectionDatasetKind `json:"kind,omitempty"`
}

// A complete lookup action as rendered in POST, PATCH, and GET responses.
type LookupAction struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// The lookup body.
	Expression string `json:"expression"`
	// A unique action ID.
	Id   string           `json:"id"`
	Kind LookupActionKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The rule that this action is part of.
	Ruleid string `json:"ruleid"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// LookupActionKind : The lookup action kind.
type LookupActionKind string

// List of LookupActionKind
const (
	LookupActionKindLookup LookupActionKind = "LOOKUP"
)

// Property values for setting existing lookup actions using a PATCH request.
type LookupActionPatch struct {
	// The lookup body.
	Expression *string           `json:"expression,omitempty"`
	Kind       *LookupActionKind `json:"kind,omitempty"`
	// The name of the user who owns this action. This value is obtained from the bearer token if not present.
	Owner *string `json:"owner,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Initial property values for creating a new lookup action using a POST request.
type LookupActionPost struct {
	// The lookup body.
	Expression string           `json:"expression"`
	Kind       LookupActionKind `json:"kind"`
	// A unique action ID.
	Id *string `json:"id,omitempty"`
	// The rule that this action is part of.
	Ruleid *string `json:"ruleid,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Properties of lookup actions which may be read, set, and changed through the API. Implementation detail of ActionPOST, ActionPOST, and Action, do not use directly.
type LookupActionProperties struct {
	// The lookup body.
	Expression *string           `json:"expression,omitempty"`
	Kind       *LookupActionKind `json:"kind,omitempty"`
}

// A complete lookup dataset as rendered in POST, PATCH, and GET responses.
type LookupDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby    string                    `json:"createdby"`
	ExternalKind LookupDatasetExternalKind `json:"externalKind"`
	// The name of the external lookup.
	ExternalName string `json:"externalName"`
	// A unique dataset ID.
	Id   string            `json:"id"`
	Kind LookupDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Match case-sensitively against the lookup.
	CaseSensitiveMatch *bool `json:"caseSensitiveMatch,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// A query that filters results out of the lookup before those results are returned.
	Filter *string `json:"filter,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// LookupDatasetExternalKind : The type of the external lookup.
type LookupDatasetExternalKind string

// List of LookupDatasetExternalKind
const (
	LookupDatasetExternalKindKvcollection LookupDatasetExternalKind = "kvcollection"
)

// LookupDatasetKind : The dataset kind.
type LookupDatasetKind string

// List of LookupDatasetKind
const (
	LookupDatasetKindLookup LookupDatasetKind = "lookup"
)

// Property values to be set in an existing lookup dataset using a PATCH request.
type LookupDatasetPatch struct {
	// Match case-sensitively against the lookup.
	CaseSensitiveMatch *bool                      `json:"caseSensitiveMatch,omitempty"`
	ExternalKind       *LookupDatasetExternalKind `json:"externalKind,omitempty"`
	// The name of the external lookup.
	ExternalName *string `json:"externalName,omitempty"`
	// A query that filters results out of the lookup before those results are returned.
	Filter *string            `json:"filter,omitempty"`
	Kind   *LookupDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Initial property values for creating a new lookup dataset using a POST request.
type LookupDatasetPost struct {
	ExternalKind LookupDatasetExternalKind `json:"externalKind"`
	// The name of the external lookup.
	ExternalName string            `json:"externalName"`
	Kind         LookupDatasetKind `json:"kind"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// Match case-sensitively against the lookup.
	CaseSensitiveMatch *bool `json:"caseSensitiveMatch,omitempty"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// A query that filters results out of the lookup before those results are returned.
	Filter *string `json:"filter,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Properties of lookup datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type LookupDatasetProperties struct {
	// Match case-sensitively against the lookup.
	CaseSensitiveMatch *bool                      `json:"caseSensitiveMatch,omitempty"`
	ExternalKind       *LookupDatasetExternalKind `json:"externalKind,omitempty"`
	// The name of the external lookup.
	ExternalName *string `json:"externalName,omitempty"`
	// A query that filters results out of the lookup before those results are returned.
	Filter *string            `json:"filter,omitempty"`
	Kind   *LookupDatasetKind `json:"kind,omitempty"`
}

// Created, createdby, modified, modifiedby, and owner properties for inclusion in other objects.
type MetadataProperties struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the object's owner.
	Owner string `json:"owner"`
}

// A complete metric dataset as rendered in POST, PATCH, and GET responses.
type MetricDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// Specifies whether or not the Splunk index is disabled.
	Disabled bool `json:"disabled"`
	// A unique dataset ID.
	Id   string            `json:"id"`
	Kind MetricDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The timestamp, in seconds, of the earliest measure. The timestamp is in UNIX time.
	EarliestEventTime *string `json:"earliestEventTime,omitempty"`
	// The earliest index time for any of the measures in this index.
	EarliestIngestTime *string `json:"earliestIngestTime,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32 `json:"frozenTimePeriodInSecs,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// The timestamp, in seconds, of the latest measure. The timestamp is in UNIX time.
	LatestEventTime *string `json:"latestEventTime,omitempty"`
	// The earliest index time for any of the measures in this index.
	LatestIngestTime *string `json:"latestIngestTime,omitempty"`
	// The latest time that the metric index metadata was refreshed.
	LatestMetadataUpdateTime *string `json:"latestMetadataUpdateTime,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// THe number of measures in the metric index.
	TotalEventCount *int32 `json:"totalEventCount,omitempty"`
	// For metrics indexes, the totalSize is set to 0.
	TotalSize *int32 `json:"totalSize,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// MetricDatasetKind : The dataset kind.
type MetricDatasetKind string

// List of MetricDatasetKind
const (
	MetricDatasetKindMetric MetricDatasetKind = "metric"
)

// Property values to be set in an existing metric dataset using a PATCH request.
type MetricDatasetPatch struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32             `json:"frozenTimePeriodInSecs,omitempty"`
	Kind                   *MetricDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Initial property values for creating a new metric dataset using a POST request.
type MetricDatasetPost struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled bool              `json:"disabled"`
	Kind     MetricDatasetKind `json:"kind"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32 `json:"frozenTimePeriodInSecs,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Properties of metric datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type MetricDatasetProperties struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32             `json:"frozenTimePeriodInSecs,omitempty"`
	Kind                   *MetricDatasetKind `json:"kind,omitempty"`
}

// Properties of metric datasets which can only be read through the API.
type MetricDatasetReadOnlyProperties struct {
	// The timestamp, in seconds, of the earliest measure. The timestamp is in UNIX time.
	EarliestEventTime *string `json:"earliestEventTime,omitempty"`
	// The earliest index time for any of the measures in this index.
	EarliestIngestTime *string            `json:"earliestIngestTime,omitempty"`
	Kind               *MetricDatasetKind `json:"kind,omitempty"`
	// The timestamp, in seconds, of the latest measure. The timestamp is in UNIX time.
	LatestEventTime *string `json:"latestEventTime,omitempty"`
	// The earliest index time for any of the measures in this index.
	LatestIngestTime *string `json:"latestIngestTime,omitempty"`
	// The latest time that the metric index metadata was refreshed.
	LatestMetadataUpdateTime *string `json:"latestMetadataUpdateTime,omitempty"`
	// THe number of measures in the metric index.
	TotalEventCount *int32 `json:"totalEventCount,omitempty"`
	// For metrics indexes, the totalSize is set to 0.
	TotalSize *int32 `json:"totalSize,omitempty"`
}

// The name of a module.
type Module struct {
	Name *string `json:"name,omitempty"`
}

// A complete regex action as rendered in POST, PATCH, and GET responses.
type RegexAction struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// Name of the field that is matched against the regular expression.
	Field string `json:"field"`
	// A unique action ID.
	Id   string          `json:"id"`
	Kind RegexActionKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// A regular expression that includes named capture groups for the purpose of field extraction.
	Pattern string `json:"pattern"`
	// The rule that this action is part of.
	Ruleid string `json:"ruleid"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// The maximum number of times per event to attempt to match fields with the regular expression.
	Limit *int32 `json:"limit,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// RegexActionKind : The regex action kind.
type RegexActionKind string

// List of RegexActionKind
const (
	RegexActionKindRegex RegexActionKind = "REGEX"
)

// Property values for setting existing regex actions using a PATCH request.
type RegexActionPatch struct {
	// Name of the field that is matched against the regular expression.
	Field *string          `json:"field,omitempty"`
	Kind  *RegexActionKind `json:"kind,omitempty"`
	// The maximum number of times per event to attempt to match fields with the regular expression.
	Limit *int32 `json:"limit,omitempty"`
	// The name of the user who owns this action. This value is obtained from the bearer token if not present.
	Owner *string `json:"owner,omitempty"`
	// A regular expression that includes named capture groups for the purpose of field extraction.
	Pattern *string `json:"pattern,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Initial property values for creating a new regex action using a POST request.
type RegexActionPost struct {
	// Name of the field that is matched against the regular expression.
	Field string          `json:"field"`
	Kind  RegexActionKind `json:"kind"`
	// A regular expression that includes named capture groups for the purpose of field extraction.
	Pattern string `json:"pattern"`
	// A unique action ID.
	Id *string `json:"id,omitempty"`
	// The maximum number of times per event to attempt to match fields with the regular expression.
	Limit *int32 `json:"limit,omitempty"`
	// The rule that this action is part of.
	Ruleid *string `json:"ruleid,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Properties of regex actions which may be read, set, and changed through the API. Implementation detail of ActionPOST, ActionPOST, and Action, do not use directly.
type RegexActionProperties struct {
	// Name of the field that is matched against the regular expression.
	Field *string          `json:"field,omitempty"`
	Kind  *RegexActionKind `json:"kind,omitempty"`
	// The maximum number of times per event to attempt to match fields with the regular expression.
	Limit *int32 `json:"limit,omitempty"`
	// A regular expression that includes named capture groups for the purpose of field extraction.
	Pattern *string `json:"pattern,omitempty"`
}

// A complete relationship as rendered in POST, PATCH, and GET responses.
type Relationship struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// The relationship fields associated with the relationship.
	Fields []RelationshipField `json:"fields"`
	// A unique relationship ID.
	Id   string           `json:"id"`
	Kind RelationshipKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The module that contains the relationship.
	Module string `json:"module"`
	// The relationship name.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// A unique source dataset ID. Either the sourceid or sourceresourcename property must be specified.
	Sourceid string `json:"sourceid"`
	// A unique target dataset ID. Either the targetid or targetresourcename property must be specified.
	Targetid string `json:"targetid"`
	// The Catalog version.
	Version int32 `json:"version"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// The source dataset name qualified by module name. Either the sourceid or sourceresourcename property must be specified.
	Sourceresourcename *string `json:"sourceresourcename,omitempty"`
	// The target dataset name qualified by module name. Either the targetid or targetresourcename property must be specified.
	Targetresourcename *string `json:"targetresourcename,omitempty"`
}

// A complete relationship field as rendered in POST, PATCH, and GET responses.
type RelationshipField struct {
	// The date and time object was created.
	Created string                `json:"created"`
	Kind    RelationshipFieldKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// A unique source dataset ID.
	Sourceid string `json:"sourceid"`
	// A unique target dataset ID.
	Targetid string `json:"targetid"`
	// A unique relationship ID.
	Relationshipid *string `json:"relationshipid,omitempty"`
}

// RelationshipFieldKind : The type of match between the fields. Must be one of the valid values. The LATEST_BEFORE match type specifies that the datetime field in one dataset binds to the latest time before the datetime field in another dataset.
type RelationshipFieldKind string

// List of RelationshipFieldKind
const (
	RelationshipFieldKindExact        RelationshipFieldKind = "EXACT"
	RelationshipFieldKindLatestBefore RelationshipFieldKind = "LATEST_BEFORE"
)

// The properties required to create a new relationship field using a relationship POST request.
type RelationshipFieldPost struct {
	Kind RelationshipFieldKind `json:"kind"`
	// A unique source dataset ID.
	Sourceid string `json:"sourceid"`
	// A unique target dataset ID.
	Targetid string `json:"targetid"`
	// A unique relationship ID.
	Relationshipid *string `json:"relationshipid,omitempty"`
}

// Properties of relationship fields which are read through the API. Implementation detail of RelationshipFieldPOST. Do not use directly.
type RelationshipFieldProperties struct {
	Kind *RelationshipFieldKind `json:"kind,omitempty"`
	// A unique relationship ID.
	Relationshipid *string `json:"relationshipid,omitempty"`
	// A unique source dataset ID.
	Sourceid *string `json:"sourceid,omitempty"`
	// A unique target dataset ID.
	Targetid *string `json:"targetid,omitempty"`
}

// RelationshipKind : The relationship type. Must be one of the valid values.
type RelationshipKind string

// List of RelationshipKind
const (
	RelationshipKindOne        RelationshipKind = "ONE"
	RelationshipKindMany       RelationshipKind = "MANY"
	RelationshipKindDependency RelationshipKind = "DEPENDENCY"
)

type RelationshipPatch struct {
	// The name of the relationship.
	Name *string `json:"name,omitempty"`
	// The user who is the owner of the relationship.
	Owner *string `json:"owner,omitempty"`
}

// The properties required to create a new relationship using a POST request.
type RelationshipPost struct {
	Kind RelationshipKind `json:"kind"`
	// The relationship name.
	Name string `json:"name"`
	// The fields associated with this relationship.
	Fields []RelationshipFieldPost `json:"fields,omitempty"`
	// A unique relationship ID. If not specified, an auto generated ID is created.
	Id *string `json:"id,omitempty"`
	// The module that contains the relationship.
	Module *string `json:"module,omitempty"`
	// A unique source dataset ID. Either the sourceid or sourceresourcename property must be specified.
	Sourceid *string `json:"sourceid,omitempty"`
	// The source dataset name qualified by module name. Either the sourceid or sourceresourcename property must be specified.
	Sourceresourcename *string `json:"sourceresourcename,omitempty"`
	// A unique target dataset ID. Either the targetid or targetresourcename property must be specified.
	Targetid *string `json:"targetid,omitempty"`
	// The target dataset name qualified by module name. Either the targetid or targetresourcename property must be specified.
	Targetresourcename *string `json:"targetresourcename,omitempty"`
	// The Catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Properties of relationships which are read through the API. Implementation detail of RelationshipPOST, RelationshipPATCH and Relationship. Do not use directly.
type RelationshipProperties struct {
	Kind *RelationshipKind `json:"kind,omitempty"`
	// The module that contains the relationship.
	Module *string `json:"module,omitempty"`
	// The relationship name.
	Name *string `json:"name,omitempty"`
	// A unique source dataset ID. Either the sourceid or sourceresourcename property must be specified.
	Sourceid *string `json:"sourceid,omitempty"`
	// The source dataset name qualified by module name. Either the sourceid or sourceresourcename property must be specified.
	Sourceresourcename *string `json:"sourceresourcename,omitempty"`
	// A unique target dataset ID. Either the targetid or targetresourcename property must be specified.
	Targetid *string `json:"targetid,omitempty"`
	// The target dataset name qualified by module name. Either the targetid or targetresourcename property must be specified.
	Targetresourcename *string `json:"targetresourcename,omitempty"`
	// The Catalog version.
	Version *int32 `json:"version,omitempty"`
}

// A complete rule as rendered in POST, PATCH, and GET responses.
type Rule struct {
	// The actions associated with the rule.
	Actions []Action `json:"actions"`
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// A unique Rule ID.
	Id string `json:"id"`
	// The rule match type.
	Match string `json:"match"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The module containing the rule.
	Module string `json:"module"`
	// The rule name.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The rule name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

type RulePatch struct {
	// The rule match type.
	Match *string `json:"match,omitempty"`
	// The module containing the rule.
	Module *string `json:"module,omitempty"`
	// The rule name.
	Name *string `json:"name,omitempty"`
	// The name of the user who owns the rule.
	Owner *string `json:"owner,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Initial property values for creating a new rule using a POST request.
type RulePost struct {
	// The rule match type.
	Match string `json:"match"`
	// The rule name.
	Name string `json:"name"`
	// The actions to be associated with this rule.
	Actions []ActionPost `json:"actions,omitempty"`
	// A unique rule ID. The newly created rule object will use this ID value if provided.
	Id *string `json:"id,omitempty"`
	// The module containing the rule.
	Module *string `json:"module,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Properties of rules which may be read, set, and changed through the API. Implementation detail of RulePOST, RulePATCH, and Rule, do not use directly.
type RuleProperties struct {
	// The rule match type.
	Match *string `json:"match,omitempty"`
	// The module containing the rule.
	Module *string `json:"module,omitempty"`
	// The rule name.
	Name *string `json:"name,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// A complete catalog dataset as rendered in GET responses.
type Splv1sinkDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// A unique dataset ID.
	Id   string               `json:"id"`
	Kind Splv1sinkDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// Internal use by common-ast, contains the converted SPL for a SPL2 search query.
	Splv1 string `json:"splv1"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// Splv1sinkDatasetKind : The dataset kind.
type Splv1sinkDatasetKind string

// List of Splv1sinkDatasetKind
const (
	Splv1sinkDatasetKindSplv1sink Splv1sinkDatasetKind = "splv1sink"
)

// Properties of splv1sink datasets which can be read through the API.
type Splv1sinkDatasetProperties struct {
	Kind *Splv1sinkDatasetKind `json:"kind,omitempty"`
	// Internal use by common-ast, contains the converted SPL for a SPL2 search query.
	Splv1 *string `json:"splv1,omitempty"`
}

// Owner, createdby, and modifiedby user name properties for inclusion in other objects.
type UserMetadataProperties struct {
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the object's owner.
	Owner string `json:"owner"`
}

// A complete view dataset as rendered in POST, PATCH, and GET responses.
type ViewDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// A unique dataset ID.
	Id   string          `json:"id"`
	Kind ViewDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the module that contains the dataset.
	Module string `json:"module"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// A valid SPL-defined search.
	Search string `json:"search"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The dataset name qualified by the module name, primarily used to distinguish between index/metric versus other datasets. Index/metric datasets have a distinct underscore separator (_____) between name and module. Internal use only.
	Internalname *string `json:"internalname,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// The catalog version.
	Version *int32 `json:"version,omitempty"`
}

// ViewDatasetKind : The dataset kind.
type ViewDatasetKind string

// List of ViewDatasetKind
const (
	ViewDatasetKindView ViewDatasetKind = "view"
)

// Property values to be set in an existing view dataset using a PATCH request.
type ViewDatasetPatch struct {
	Kind *ViewDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
	// A valid SPL-defined search.
	Search *string `json:"search,omitempty"`
}

// Initial property values for creating a new view dataset using a POST request.
type ViewDatasetPost struct {
	Kind ViewDatasetKind `json:"kind"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// A valid SPL-defined search.
	Search string `json:"search"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Properties of job datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type ViewDatasetProperties struct {
	Kind *ViewDatasetKind `json:"kind,omitempty"`
	// A valid SPL-defined search.
	Search *string `json:"search,omitempty"`
}
