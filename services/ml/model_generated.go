/*
 * Copyright Â© 2020 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * Machine Learning
 *
 * Use the Machine Learning service in Splunk Cloud Services to deliver resource intensive machine learning workloads. The Machine Learning service covers model experimentation, training, inference, validation, scoring, and serving.
 *
 * API version: v2beta1.1 (recommended default)
 * Generated by: OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
 */

package ml

import (
	"bytes"
	"encoding/json"
)

type ClassificationReport map[string]interface{}

type ClusteringReport map[string]interface{}

type CrossValidation struct {
	// Number of folds in the K-fold cross validation.
	KFold *int32 `json:"kFold,omitempty"`
	// Random state to shuffle and partition data.
	RandomSeed *int32 `json:"randomSeed,omitempty"`
	// Determine whether stratification is used in partitioning the data.
	Stratified *bool `json:"stratified,omitempty"`
}

type CrossValidationScore []map[string]interface{}

type DeploymentSpec struct {
	// CPU Resource limit for each container in a deployment.
	CpuLimit *string `json:"cpuLimit,omitempty"`
	// CPU Resource limit for serving requests.
	CpuRequest *string `json:"cpuRequest,omitempty"`
	// Memory Resource limit for each container in a deployment.
	MemoryLimit *string `json:"memoryLimit,omitempty"`
	// Memory Resource limit for serving requests.
	MemoryRequest *string `json:"memoryRequest,omitempty"`
	// Create replicated pods in a deployment.
	Replicas *int32 `json:"replicas,omitempty"`
}

type Error struct {
	Code    string                   `json:"code"`
	Message string                   `json:"message"`
	Details []map[string]interface{} `json:"details,omitempty"`
}

// Output events to the Ingest /events endpoint.
type Events struct {
	// Specifies a JSON object that contains explicit custom fields to be defined at index time.
	Attributes map[string]interface{} `json:"attributes,omitempty"`
	// Splunk host field.
	Host *string `json:"host,omitempty"`
	// Splunk source field.
	Source *string `json:"source,omitempty"`
	// Splunk sourcetype field.
	Sourcetype *string `json:"sourcetype,omitempty"`
}

// Executor errors.
type ExecutorErrors struct {
	Message *string `json:"message,omitempty"`
}

// Executor logs.
type ExecutorLogs struct {
	Level   *string `json:"level,omitempty"`
	Message *string `json:"message,omitempty"`
}

type Fields struct {
	// Fields necessary for task.
	Features []string `json:"features"`
	// Fields produced by task.
	Created []string `json:"created,omitempty"`
	// Target field necessary for task.
	Target *string `json:"target,omitempty"`
}

// Fit task does an estimation/training/fitting, fit task outputs a transformer.
type FitTask struct {
	Algorithm string       `json:"algorithm"`
	Fields    Fields       `json:"fields"`
	Kind      *FitTaskKind `json:"kind,omitempty"`
	// The name has to be unique in the same workflow, it is optional, can be used to identify that task artifact.
	Name              *string                `json:"name,omitempty"`
	OutputTransformer *string                `json:"outputTransformer,omitempty"`
	Parameters        map[string]interface{} `json:"parameters,omitempty"`
}

type FitTaskKind string

// List of FitTaskKind
const (
	FitTaskKindFit FitTaskKind = "fit"
)

type ForecastingReport map[string]interface{}

type InputData struct {
	Kind   InputDataKind   `json:"kind"`
	Source InputDataSource `json:"source"`
}

type InputDataKind string

// List of InputDataKind
const (
	InputDataKindSpl     InputDataKind = "SPL"
	InputDataKindRawData InputDataKind = "RawData"
)

// InputDataSource is RawData, Spl, (or interface{} if no matches are found)
type InputDataSource struct {
	inputDataSource interface{}
	isRaw           bool
}

// UnmarshalJSON unmarshals InputDataSource into RawData, Spl, or interface{} if no matches are found
func (m *InputDataSource) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testRawData RawData
	if err = attempt(&testRawData); err == nil {
		m.inputDataSource = testRawData
		return nil
	}
	var testSpl Spl
	if err = attempt(&testSpl); err == nil {
		m.inputDataSource = testSpl
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.inputDataSource = raw
	return nil
}

// MarshalJSON marshals InputDataSource using InputDataSource.InputDataSource
func (m InputDataSource) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.inputDataSource)
}

// MakeInputDataSourceFromRawData creates a new InputDataSource from an instance of RawData
func MakeInputDataSourceFromRawData(f RawData) InputDataSource {
	return InputDataSource{inputDataSource: f}
}

// IsRawData checks if the InputDataSource is a RawData
func (m InputDataSource) IsRawData() bool {
	_, ok := m.inputDataSource.(RawData)
	return ok
}

// RawData returns RawData if IsRawData() is true, nil otherwise
func (m InputDataSource) RawData() *RawData {
	if v, ok := m.inputDataSource.(RawData); ok {
		return &v
	}
	return nil
}

// MakeInputDataSourceFromSpl creates a new InputDataSource from an instance of Spl
func MakeInputDataSourceFromSpl(f Spl) InputDataSource {
	return InputDataSource{inputDataSource: f}
}

// IsSpl checks if the InputDataSource is a Spl
func (m InputDataSource) IsSpl() bool {
	_, ok := m.inputDataSource.(Spl)
	return ok
}

// Spl returns Spl if IsSpl() is true, nil otherwise
func (m InputDataSource) Spl() *Spl {
	if v, ok := m.inputDataSource.(Spl); ok {
		return &v
	}
	return nil
}

// MakeInputDataSourceFromRawInterface creates a new InputDataSource from a raw interface{}
func MakeInputDataSourceFromRawInterface(f interface{}) InputDataSource {
	return InputDataSource{
		inputDataSource: f,
		isRaw:           true,
	}
}

// IsRawInterface checks if the InputDataSource is an interface{} (unknown type)
func (m InputDataSource) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m InputDataSource) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.inputDataSource
}

type InputStream struct {
	Kind   InputStreamKind   `json:"kind"`
	Source InputStreamSource `json:"source"`
}

type InputStreamKind string

// List of InputStreamKind
const (
	InputStreamKindKafka InputStreamKind = "Kafka"
)

// InputStreamSource is KafkaInput, (or interface{} if no matches are found)
type InputStreamSource struct {
	inputStreamSource interface{}
	isRaw             bool
}

// UnmarshalJSON unmarshals InputStreamSource into KafkaInput, or interface{} if no matches are found
func (m *InputStreamSource) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testKafkaInput KafkaInput
	if err = attempt(&testKafkaInput); err == nil {
		m.inputStreamSource = testKafkaInput
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.inputStreamSource = raw
	return nil
}

// MarshalJSON marshals InputStreamSource using InputStreamSource.InputStreamSource
func (m InputStreamSource) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.inputStreamSource)
}

// MakeInputStreamSourceFromKafkaInput creates a new InputStreamSource from an instance of KafkaInput
func MakeInputStreamSourceFromKafkaInput(f KafkaInput) InputStreamSource {
	return InputStreamSource{inputStreamSource: f}
}

// IsKafkaInput checks if the InputStreamSource is a KafkaInput
func (m InputStreamSource) IsKafkaInput() bool {
	_, ok := m.inputStreamSource.(KafkaInput)
	return ok
}

// KafkaInput returns KafkaInput if IsKafkaInput() is true, nil otherwise
func (m InputStreamSource) KafkaInput() *KafkaInput {
	if v, ok := m.inputStreamSource.(KafkaInput); ok {
		return &v
	}
	return nil
}

// MakeInputStreamSourceFromRawInterface creates a new InputStreamSource from a raw interface{}
func MakeInputStreamSourceFromRawInterface(f interface{}) InputStreamSource {
	return InputStreamSource{
		inputStreamSource: f,
		isRaw:             true,
	}
}

// IsRawInterface checks if the InputStreamSource is an interface{} (unknown type)
func (m InputStreamSource) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m InputStreamSource) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.inputStreamSource
}

type InputStreamSourceOffsetReset string

// List of InputStreamSourceOffsetReset
const (
	InputStreamSourceOffsetResetEarliest InputStreamSourceOffsetReset = "earliest"
	InputStreamSourceOffsetResetLatest   InputStreamSourceOffsetReset = "latest"
)

type KafkaInput struct {
	Topic       string                 `json:"topic"`
	OffsetReset *KafkaInputOffsetReset `json:"offsetReset,omitempty"`
}

type KafkaInputOffsetReset string

// List of KafkaInputOffsetReset
const (
	KafkaInputOffsetResetEarliest KafkaInputOffsetReset = "earliest"
	KafkaInputOffsetResetLatest   KafkaInputOffsetReset = "latest"
)

type KafkaOutput struct {
	Topic string `json:"topic"`
}

type OutputData struct {
	Destination *OutputDataDestination `json:"destination,omitempty"`
	Kind        *OutputDataKind        `json:"kind,omitempty"`
}

type OutputDataKind string

// List of OutputDataKind
const (
	OutputDataKindEvents OutputDataKind = "Events"
)

// OutputDataDestination is Events, (or interface{} if no matches are found)
type OutputDataDestination struct {
	outputDataDestination interface{}
	isRaw                 bool
}

// UnmarshalJSON unmarshals OutputDataDestination into Events, or interface{} if no matches are found
func (m *OutputDataDestination) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testEvents Events
	if err = attempt(&testEvents); err == nil {
		m.outputDataDestination = testEvents
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.outputDataDestination = raw
	return nil
}

// MarshalJSON marshals OutputDataDestination using OutputDataDestination.OutputDataDestination
func (m OutputDataDestination) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.outputDataDestination)
}

// MakeOutputDataDestinationFromEvents creates a new OutputDataDestination from an instance of Events
func MakeOutputDataDestinationFromEvents(f Events) OutputDataDestination {
	return OutputDataDestination{outputDataDestination: f}
}

// IsEvents checks if the OutputDataDestination is a Events
func (m OutputDataDestination) IsEvents() bool {
	_, ok := m.outputDataDestination.(Events)
	return ok
}

// Events returns Events if IsEvents() is true, nil otherwise
func (m OutputDataDestination) Events() *Events {
	if v, ok := m.outputDataDestination.(Events); ok {
		return &v
	}
	return nil
}

// MakeOutputDataDestinationFromRawInterface creates a new OutputDataDestination from a raw interface{}
func MakeOutputDataDestinationFromRawInterface(f interface{}) OutputDataDestination {
	return OutputDataDestination{
		outputDataDestination: f,
		isRaw:                 true,
	}
}

// IsRawInterface checks if the OutputDataDestination is an interface{} (unknown type)
func (m OutputDataDestination) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m OutputDataDestination) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.outputDataDestination
}

type OutputStream struct {
	Destination OutputStreamDestination `json:"destination"`
	Kind        OutputStreamKind        `json:"kind"`
}

type OutputStreamKind string

// List of OutputStreamKind
const (
	OutputStreamKindKafka OutputStreamKind = "Kafka"
)

// OutputStreamDestination is KafkaOutput, (or interface{} if no matches are found)
type OutputStreamDestination struct {
	outputStreamDestination interface{}
	isRaw                   bool
}

// UnmarshalJSON unmarshals OutputStreamDestination into KafkaOutput, or interface{} if no matches are found
func (m *OutputStreamDestination) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testKafkaOutput KafkaOutput
	if err = attempt(&testKafkaOutput); err == nil {
		m.outputStreamDestination = testKafkaOutput
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.outputStreamDestination = raw
	return nil
}

// MarshalJSON marshals OutputStreamDestination using OutputStreamDestination.OutputStreamDestination
func (m OutputStreamDestination) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.outputStreamDestination)
}

// MakeOutputStreamDestinationFromKafkaOutput creates a new OutputStreamDestination from an instance of KafkaOutput
func MakeOutputStreamDestinationFromKafkaOutput(f KafkaOutput) OutputStreamDestination {
	return OutputStreamDestination{outputStreamDestination: f}
}

// IsKafkaOutput checks if the OutputStreamDestination is a KafkaOutput
func (m OutputStreamDestination) IsKafkaOutput() bool {
	_, ok := m.outputStreamDestination.(KafkaOutput)
	return ok
}

// KafkaOutput returns KafkaOutput if IsKafkaOutput() is true, nil otherwise
func (m OutputStreamDestination) KafkaOutput() *KafkaOutput {
	if v, ok := m.outputStreamDestination.(KafkaOutput); ok {
		return &v
	}
	return nil
}

// MakeOutputStreamDestinationFromRawInterface creates a new OutputStreamDestination from a raw interface{}
func MakeOutputStreamDestinationFromRawInterface(f interface{}) OutputStreamDestination {
	return OutputStreamDestination{
		outputStreamDestination: f,
		isRaw:                   true,
	}
}

// IsRawInterface checks if the OutputStreamDestination is an interface{} (unknown type)
func (m OutputStreamDestination) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m OutputStreamDestination) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.outputStreamDestination
}

// Send data directly via the reqest body as a base-64 encoded CSV string.
type RawData struct {
	// A base-64 encoded CSV string.
	Data *string `json:"data,omitempty"`
}

type RegressionReport map[string]interface{}

type Score struct {
	Kind   ScoreKind   `json:"kind"`
	Report ScoreReport `json:"report"`
}

type ScoreKind string

// List of ScoreKind
const (
	ScoreKindRegression     ScoreKind = "regression"
	ScoreKindClassification ScoreKind = "classification"
	ScoreKindClustering     ScoreKind = "clustering"
	ScoreKindForecasting    ScoreKind = "forecasting"
)

// ScoreReport is ClassificationReport, ClusteringReport, ForecastingReport, RegressionReport, (or interface{} if no matches are found)
type ScoreReport struct {
	scoreReport interface{}
	isRaw       bool
}

// UnmarshalJSON unmarshals ScoreReport into ClassificationReport, ClusteringReport, ForecastingReport, RegressionReport, or interface{} if no matches are found
func (m *ScoreReport) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testClassificationReport ClassificationReport
	if err = attempt(&testClassificationReport); err == nil {
		m.scoreReport = testClassificationReport
		return nil
	}
	var testClusteringReport ClusteringReport
	if err = attempt(&testClusteringReport); err == nil {
		m.scoreReport = testClusteringReport
		return nil
	}
	var testForecastingReport ForecastingReport
	if err = attempt(&testForecastingReport); err == nil {
		m.scoreReport = testForecastingReport
		return nil
	}
	var testRegressionReport RegressionReport
	if err = attempt(&testRegressionReport); err == nil {
		m.scoreReport = testRegressionReport
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.scoreReport = raw
	return nil
}

// MarshalJSON marshals ScoreReport using ScoreReport.ScoreReport
func (m ScoreReport) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.scoreReport)
}

// MakeScoreReportFromClassificationReport creates a new ScoreReport from an instance of ClassificationReport
func MakeScoreReportFromClassificationReport(f ClassificationReport) ScoreReport {
	return ScoreReport{scoreReport: f}
}

// IsClassificationReport checks if the ScoreReport is a ClassificationReport
func (m ScoreReport) IsClassificationReport() bool {
	_, ok := m.scoreReport.(ClassificationReport)
	return ok
}

// ClassificationReport returns ClassificationReport if IsClassificationReport() is true, nil otherwise
func (m ScoreReport) ClassificationReport() *ClassificationReport {
	if v, ok := m.scoreReport.(ClassificationReport); ok {
		return &v
	}
	return nil
}

// MakeScoreReportFromClusteringReport creates a new ScoreReport from an instance of ClusteringReport
func MakeScoreReportFromClusteringReport(f ClusteringReport) ScoreReport {
	return ScoreReport{scoreReport: f}
}

// IsClusteringReport checks if the ScoreReport is a ClusteringReport
func (m ScoreReport) IsClusteringReport() bool {
	_, ok := m.scoreReport.(ClusteringReport)
	return ok
}

// ClusteringReport returns ClusteringReport if IsClusteringReport() is true, nil otherwise
func (m ScoreReport) ClusteringReport() *ClusteringReport {
	if v, ok := m.scoreReport.(ClusteringReport); ok {
		return &v
	}
	return nil
}

// MakeScoreReportFromForecastingReport creates a new ScoreReport from an instance of ForecastingReport
func MakeScoreReportFromForecastingReport(f ForecastingReport) ScoreReport {
	return ScoreReport{scoreReport: f}
}

// IsForecastingReport checks if the ScoreReport is a ForecastingReport
func (m ScoreReport) IsForecastingReport() bool {
	_, ok := m.scoreReport.(ForecastingReport)
	return ok
}

// ForecastingReport returns ForecastingReport if IsForecastingReport() is true, nil otherwise
func (m ScoreReport) ForecastingReport() *ForecastingReport {
	if v, ok := m.scoreReport.(ForecastingReport); ok {
		return &v
	}
	return nil
}

// MakeScoreReportFromRegressionReport creates a new ScoreReport from an instance of RegressionReport
func MakeScoreReportFromRegressionReport(f RegressionReport) ScoreReport {
	return ScoreReport{scoreReport: f}
}

// IsRegressionReport checks if the ScoreReport is a RegressionReport
func (m ScoreReport) IsRegressionReport() bool {
	_, ok := m.scoreReport.(RegressionReport)
	return ok
}

// RegressionReport returns RegressionReport if IsRegressionReport() is true, nil otherwise
func (m ScoreReport) RegressionReport() *RegressionReport {
	if v, ok := m.scoreReport.(RegressionReport); ok {
		return &v
	}
	return nil
}

// MakeScoreReportFromRawInterface creates a new ScoreReport from a raw interface{}
func MakeScoreReportFromRawInterface(f interface{}) ScoreReport {
	return ScoreReport{
		scoreReport: f,
		isRaw:       true,
	}
}

// IsRawInterface checks if the ScoreReport is an interface{} (unknown type)
func (m ScoreReport) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m ScoreReport) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.scoreReport
}

type Spl struct {
	Query string `json:"query"`
	// Determine whether the Search service extracts all available fields in the data, including fields not mentioned in the SPL for the search job. Set to 'false' for better search performance.
	ExtractAllFields *bool `json:"extractAllFields,omitempty"`
	// The number of seconds to run this search before finalizing.
	MaxTime *int32 `json:"maxTime,omitempty"`
	// The module to run the search in. The default module is used if a module is not specified.
	Module *string `json:"module,omitempty"`
	// Represents parameters on the search job such as 'earliest' and 'latest'.
	QueryParameters map[string]interface{} `json:"queryParameters,omitempty"`
}

type Task struct {
	fitTask *FitTask
	raw     interface{}
}

// MakeTaskFromFitTask creates a new Task from an instance of FitTask
func MakeTaskFromFitTask(f FitTask) Task {
	return Task{fitTask: &f}
}

// IsFitTask checks if the Task is a FitTask
func (m Task) IsFitTask() bool {
	return m.fitTask != nil
}

// FitTask returns FitTask if IsFitTask() is true, nil otherwise
func (m Task) FitTask() *FitTask {
	return m.fitTask
}

// MakeTaskFromRawInterface creates a new Task from a raw interface{}
func MakeTaskFromRawInterface(f interface{}) Task {
	return Task{raw: f}
}

// IsRawInterface checks if the Task is an interface{} (unknown type)
func (m Task) IsRawInterface() bool {
	return m.raw != nil
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m Task) RawInterface() interface{} {
	return m.raw
}

// UnmarshalJSON unmarshals Task using the "kind" property
func (m *Task) UnmarshalJSON(b []byte) (err error) {
	type discriminator struct {
		Kind string `json:"kind"`
	}
	var d discriminator
	err = json.Unmarshal(b, &d)
	if err != nil {
		return err
	}
	// Resolve into respective struct based on the discriminator value
	switch d.Kind {
	case "fit":
		m.fitTask = &FitTask{}
		return json.Unmarshal(b, m.fitTask)
	}
	// Unknown discriminator value (this type may not yet be supported)
	// unmarhsal to raw interface
	var raw interface{}
	err = json.Unmarshal(b, &raw)
	if err != nil {
		return err
	}
	m.raw = raw
	return nil
}

// MarshalJSON marshals Task using the appropriate struct field
func (m Task) MarshalJSON() ([]byte, error) {
	if m.IsFitTask() {
		return json.Marshal(m.fitTask)
	}
	// None of the structs are populated, send raw
	return json.Marshal(m.raw)
}

type TaskKind string

// List of TaskKind
const (
	TaskKindFit TaskKind = "fit"
)

type TaskCommon struct {
	Kind *TaskCommonKind `json:"kind,omitempty"`
	// The name has to be unique in the same workflow, it is optional, can be used to identify that task artifact.
	Name *string `json:"name,omitempty"`
}

type TaskCommonKind string

// List of TaskCommonKind
const (
	TaskCommonKindFit TaskCommonKind = "fit"
)

type TaskSummary struct {
	Algorithm *string `json:"algorithm,omitempty"`
	Name      *string `json:"name,omitempty"`
	// Summary of the task, including but not limited to learned parameters and statistics.
	Summary interface{} `json:"summary,omitempty"`
}

type TrainTestScore struct {
	TestScore     *Score `json:"testScore,omitempty"`
	TrainingScore *Score `json:"trainingScore,omitempty"`
}

type TrainTestSplit struct {
	// Random state to shuffle and partition data.
	RandomSeed *int32 `json:"randomSeed,omitempty"`
	// Ratio to split out training set and test set. For example, 0.8 means 80% of data for the training set and 20% for the test set.
	Ratio *float32 `json:"ratio,omitempty"`
	// Determine whether stratification is used in partitioning the data.
	Stratified *bool `json:"stratified,omitempty"`
}

type TrainingParameters map[string]interface{}

type Workflow struct {
	Tasks        []Task  `json:"tasks"`
	CreationTime *string `json:"creationTime,omitempty"`
	Id           *string `json:"id,omitempty"`
	Name         *string `json:"name,omitempty"`
}

type WorkflowBuild struct {
	Input           InputData            `json:"input"`
	CreationTime    *string              `json:"creationTime,omitempty"`
	EndTime         *string              `json:"endTime,omitempty"`
	Id              *string              `json:"id,omitempty"`
	Name            *string              `json:"name,omitempty"`
	Output          *OutputData          `json:"output,omitempty"`
	PipelineSummary []TaskSummary        `json:"pipelineSummary,omitempty"`
	StartTime       *string              `json:"startTime,omitempty"`
	Status          *WorkflowBuildStatus `json:"status,omitempty"`
	// Number of seconds before a workflow build times out.
	TimeoutSecs      *int32                         `json:"timeoutSecs,omitempty"`
	TrainingScore    *Score                         `json:"trainingScore,omitempty"`
	ValidationOption *WorkflowBuildValidationOption `json:"validationOption,omitempty"`
	ValidationScore  *WorkflowBuildValidationScore  `json:"validationScore,omitempty"`
	Workflow         *Workflow                      `json:"workflow,omitempty"`
}

type WorkflowBuildStatus string

// List of WorkflowBuildStatus
const (
	WorkflowBuildStatusRunning   WorkflowBuildStatus = "running"
	WorkflowBuildStatusFailed    WorkflowBuildStatus = "failed"
	WorkflowBuildStatusSuccess   WorkflowBuildStatus = "success"
	WorkflowBuildStatusScheduled WorkflowBuildStatus = "scheduled"
)

type WorkflowBuildError struct {
	Id                    string                  `json:"id"`
	WorkflowId            string                  `json:"workflowId"`
	ExecutorErrors        []ExecutorErrors        `json:"executorErrors,omitempty"`
	RequestId             *string                 `json:"requestId,omitempty"`
	WorkflowManagerErrors []WorkflowManagerErrors `json:"workflowManagerErrors,omitempty"`
}

type WorkflowBuildLog struct {
	Id                  string                `json:"id"`
	WorkflowId          string                `json:"workflowId"`
	ExecutorLogs        []ExecutorLogs        `json:"executorLogs,omitempty"`
	RequestId           *string               `json:"requestId,omitempty"`
	WorkflowManagerLogs []WorkflowManagerLogs `json:"workflowManagerLogs,omitempty"`
}

// Represents which type of validation to use in the workflow along with any parameters if specified. If this is not included, no validation is done (all data is used for training). Default parameter values are used if no `option` is specified.
type WorkflowBuildValidationOption struct {
	Kind   WorkflowBuildValidationOptionKind `json:"kind"`
	Option *WorkflowValidationOption         `json:"option,omitempty"`
}

type WorkflowBuildValidationOptionKind string

// List of WorkflowBuildValidationOptionKind
const (
	WorkflowBuildValidationOptionKindTrainTest       WorkflowBuildValidationOptionKind = "TrainTest"
	WorkflowBuildValidationOptionKindCrossValidation WorkflowBuildValidationOptionKind = "CrossValidation"
)

// The validation score whose type is specified by the user in `validationOption`.
type WorkflowBuildValidationScore struct {
	Kind  WorkflowBuildValidationScoreKind `json:"kind"`
	Score WorkflowValidationScore          `json:"score"`
}

type WorkflowBuildValidationScoreKind string

// List of WorkflowBuildValidationScoreKind
const (
	WorkflowBuildValidationScoreKindTrainTest       WorkflowBuildValidationScoreKind = "TrainTest"
	WorkflowBuildValidationScoreKindCrossValidation WorkflowBuildValidationScoreKind = "CrossValidation"
)

type WorkflowDeployment struct {
	Spec          DeploymentSpec            `json:"spec"`
	CreationTime  *string                   `json:"creationTime,omitempty"`
	EndTime       *string                   `json:"endTime,omitempty"`
	Id            *string                   `json:"id,omitempty"`
	Name          *string                   `json:"name,omitempty"`
	StartTime     *string                   `json:"startTime,omitempty"`
	Status        *WorkflowDeploymentStatus `json:"status,omitempty"`
	WorkflowBuild *WorkflowBuild            `json:"workflowBuild,omitempty"`
}

type WorkflowDeploymentStatus string

// List of WorkflowDeploymentStatus
const (
	WorkflowDeploymentStatusRunning      WorkflowDeploymentStatus = "running"
	WorkflowDeploymentStatusFailed       WorkflowDeploymentStatus = "failed"
	WorkflowDeploymentStatusSuccess      WorkflowDeploymentStatus = "success"
	WorkflowDeploymentStatusScheduled    WorkflowDeploymentStatus = "scheduled"
	WorkflowDeploymentStatusInitializing WorkflowDeploymentStatus = "initializing"
)

type WorkflowDeploymentError struct {
	BuildId               string                  `json:"buildId"`
	Id                    string                  `json:"id"`
	WorkflowId            string                  `json:"workflowId"`
	ExecutorErrors        []ExecutorErrors        `json:"executorErrors,omitempty"`
	RequestId             *string                 `json:"requestId,omitempty"`
	WorkflowManagerErrors []WorkflowManagerErrors `json:"workflowManagerErrors,omitempty"`
}

type WorkflowDeploymentLog struct {
	BuildId             string                `json:"buildId"`
	Id                  string                `json:"id"`
	WorkflowId          string                `json:"workflowId"`
	ExecutorLogs        []ExecutorLogs        `json:"executorLogs,omitempty"`
	RequestId           *string               `json:"requestId,omitempty"`
	WorkflowManagerLogs []WorkflowManagerLogs `json:"workflowManagerLogs,omitempty"`
}

type WorkflowInference struct {
	Input  string  `json:"input"`
	Output *string `json:"output,omitempty"`
}

// Workflow manager errors.
type WorkflowManagerErrors struct {
	Message *string `json:"message,omitempty"`
}

// Workflow manager logs.
type WorkflowManagerLogs struct {
	Level   *string `json:"level,omitempty"`
	Message *string `json:"message,omitempty"`
}

type WorkflowRun struct {
	Input        InputData  `json:"input"`
	Output       OutputData `json:"output"`
	CreationTime *string    `json:"creationTime,omitempty"`
	EndTime      *string    `json:"endTime,omitempty"`
	// Determine whether to evaluate the prediction.
	Evaluate        *bool              `json:"evaluate,omitempty"`
	Id              *string            `json:"id,omitempty"`
	Name            *string            `json:"name,omitempty"`
	PredictionScore *Score             `json:"predictionScore,omitempty"`
	StartTime       *string            `json:"startTime,omitempty"`
	Status          *WorkflowRunStatus `json:"status,omitempty"`
	// Number of seconds before a workflow run times out.
	TimeoutSecs   *int32         `json:"timeoutSecs,omitempty"`
	WorkflowBuild *WorkflowBuild `json:"workflowBuild,omitempty"`
}

type WorkflowRunStatus string

// List of WorkflowRunStatus
const (
	WorkflowRunStatusRunning   WorkflowRunStatus = "running"
	WorkflowRunStatusFailed    WorkflowRunStatus = "failed"
	WorkflowRunStatusSuccess   WorkflowRunStatus = "success"
	WorkflowRunStatusScheduled WorkflowRunStatus = "scheduled"
)

type WorkflowRunError struct {
	BuildId               string                  `json:"buildId"`
	Id                    string                  `json:"id"`
	WorkflowId            string                  `json:"workflowId"`
	ExecutorErrors        []ExecutorErrors        `json:"executorErrors,omitempty"`
	RequestId             *string                 `json:"requestId,omitempty"`
	WorkflowManagerErrors []WorkflowManagerErrors `json:"workflowManagerErrors,omitempty"`
}

type WorkflowRunLog struct {
	BuildId             string                `json:"buildId"`
	Id                  string                `json:"id"`
	WorkflowId          string                `json:"workflowId"`
	ExecutorLogs        []ExecutorLogs        `json:"executorLogs,omitempty"`
	RequestId           *string               `json:"requestId,omitempty"`
	WorkflowManagerLogs []WorkflowManagerLogs `json:"workflowManagerLogs,omitempty"`
}

type WorkflowStreamDeployment struct {
	Input         InputStream                     `json:"input"`
	Output        OutputStream                    `json:"output"`
	CreationTime  *string                         `json:"creationTime,omitempty"`
	EndTime       *string                         `json:"endTime,omitempty"`
	Id            *string                         `json:"id,omitempty"`
	Name          *string                         `json:"name,omitempty"`
	Spec          *DeploymentSpec                 `json:"spec,omitempty"`
	StartTime     *string                         `json:"startTime,omitempty"`
	Status        *WorkflowStreamDeploymentStatus `json:"status,omitempty"`
	WorkflowBuild *WorkflowBuild                  `json:"workflowBuild,omitempty"`
}

type WorkflowStreamDeploymentStatus string

// List of WorkflowStreamDeploymentStatus
const (
	WorkflowStreamDeploymentStatusRunning      WorkflowStreamDeploymentStatus = "running"
	WorkflowStreamDeploymentStatusFailed       WorkflowStreamDeploymentStatus = "failed"
	WorkflowStreamDeploymentStatusSuccess      WorkflowStreamDeploymentStatus = "success"
	WorkflowStreamDeploymentStatusScheduled    WorkflowStreamDeploymentStatus = "scheduled"
	WorkflowStreamDeploymentStatusInitializing WorkflowStreamDeploymentStatus = "initializing"
)

// WorkflowValidationOption is CrossValidation, TrainTestSplit, (or interface{} if no matches are found)
type WorkflowValidationOption struct {
	workflowValidationOption interface{}
	isRaw                    bool
}

// UnmarshalJSON unmarshals WorkflowValidationOption into CrossValidation, TrainTestSplit, or interface{} if no matches are found
func (m *WorkflowValidationOption) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testCrossValidation CrossValidation
	if err = attempt(&testCrossValidation); err == nil {
		m.workflowValidationOption = testCrossValidation
		return nil
	}
	var testTrainTestSplit TrainTestSplit
	if err = attempt(&testTrainTestSplit); err == nil {
		m.workflowValidationOption = testTrainTestSplit
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.workflowValidationOption = raw
	return nil
}

// MarshalJSON marshals WorkflowValidationOption using WorkflowValidationOption.WorkflowValidationOption
func (m WorkflowValidationOption) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.workflowValidationOption)
}

// MakeWorkflowValidationOptionFromCrossValidation creates a new WorkflowValidationOption from an instance of CrossValidation
func MakeWorkflowValidationOptionFromCrossValidation(f CrossValidation) WorkflowValidationOption {
	return WorkflowValidationOption{workflowValidationOption: f}
}

// IsCrossValidation checks if the WorkflowValidationOption is a CrossValidation
func (m WorkflowValidationOption) IsCrossValidation() bool {
	_, ok := m.workflowValidationOption.(CrossValidation)
	return ok
}

// CrossValidation returns CrossValidation if IsCrossValidation() is true, nil otherwise
func (m WorkflowValidationOption) CrossValidation() *CrossValidation {
	if v, ok := m.workflowValidationOption.(CrossValidation); ok {
		return &v
	}
	return nil
}

// MakeWorkflowValidationOptionFromTrainTestSplit creates a new WorkflowValidationOption from an instance of TrainTestSplit
func MakeWorkflowValidationOptionFromTrainTestSplit(f TrainTestSplit) WorkflowValidationOption {
	return WorkflowValidationOption{workflowValidationOption: f}
}

// IsTrainTestSplit checks if the WorkflowValidationOption is a TrainTestSplit
func (m WorkflowValidationOption) IsTrainTestSplit() bool {
	_, ok := m.workflowValidationOption.(TrainTestSplit)
	return ok
}

// TrainTestSplit returns TrainTestSplit if IsTrainTestSplit() is true, nil otherwise
func (m WorkflowValidationOption) TrainTestSplit() *TrainTestSplit {
	if v, ok := m.workflowValidationOption.(TrainTestSplit); ok {
		return &v
	}
	return nil
}

// MakeWorkflowValidationOptionFromRawInterface creates a new WorkflowValidationOption from a raw interface{}
func MakeWorkflowValidationOptionFromRawInterface(f interface{}) WorkflowValidationOption {
	return WorkflowValidationOption{
		workflowValidationOption: f,
		isRaw:                    true,
	}
}

// IsRawInterface checks if the WorkflowValidationOption is an interface{} (unknown type)
func (m WorkflowValidationOption) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m WorkflowValidationOption) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.workflowValidationOption
}

// WorkflowValidationScore is CrossValidationScore, TrainTestScore, (or interface{} if no matches are found)
type WorkflowValidationScore struct {
	workflowValidationScore interface{}
	isRaw                   bool
}

// UnmarshalJSON unmarshals WorkflowValidationScore into CrossValidationScore, TrainTestScore, or interface{} if no matches are found
func (m *WorkflowValidationScore) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testCrossValidationScore CrossValidationScore
	if err = attempt(&testCrossValidationScore); err == nil {
		m.workflowValidationScore = testCrossValidationScore
		return nil
	}
	var testTrainTestScore TrainTestScore
	if err = attempt(&testTrainTestScore); err == nil {
		m.workflowValidationScore = testTrainTestScore
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.workflowValidationScore = raw
	return nil
}

// MarshalJSON marshals WorkflowValidationScore using WorkflowValidationScore.WorkflowValidationScore
func (m WorkflowValidationScore) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.workflowValidationScore)
}

// MakeWorkflowValidationScoreFromCrossValidationScore creates a new WorkflowValidationScore from an instance of CrossValidationScore
func MakeWorkflowValidationScoreFromCrossValidationScore(f CrossValidationScore) WorkflowValidationScore {
	return WorkflowValidationScore{workflowValidationScore: f}
}

// IsCrossValidationScore checks if the WorkflowValidationScore is a CrossValidationScore
func (m WorkflowValidationScore) IsCrossValidationScore() bool {
	_, ok := m.workflowValidationScore.(CrossValidationScore)
	return ok
}

// CrossValidationScore returns CrossValidationScore if IsCrossValidationScore() is true, nil otherwise
func (m WorkflowValidationScore) CrossValidationScore() *CrossValidationScore {
	if v, ok := m.workflowValidationScore.(CrossValidationScore); ok {
		return &v
	}
	return nil
}

// MakeWorkflowValidationScoreFromTrainTestScore creates a new WorkflowValidationScore from an instance of TrainTestScore
func MakeWorkflowValidationScoreFromTrainTestScore(f TrainTestScore) WorkflowValidationScore {
	return WorkflowValidationScore{workflowValidationScore: f}
}

// IsTrainTestScore checks if the WorkflowValidationScore is a TrainTestScore
func (m WorkflowValidationScore) IsTrainTestScore() bool {
	_, ok := m.workflowValidationScore.(TrainTestScore)
	return ok
}

// TrainTestScore returns TrainTestScore if IsTrainTestScore() is true, nil otherwise
func (m WorkflowValidationScore) TrainTestScore() *TrainTestScore {
	if v, ok := m.workflowValidationScore.(TrainTestScore); ok {
		return &v
	}
	return nil
}

// MakeWorkflowValidationScoreFromRawInterface creates a new WorkflowValidationScore from a raw interface{}
func MakeWorkflowValidationScoreFromRawInterface(f interface{}) WorkflowValidationScore {
	return WorkflowValidationScore{
		workflowValidationScore: f,
		isRaw:                   true,
	}
}

// IsRawInterface checks if the WorkflowValidationScore is an interface{} (unknown type)
func (m WorkflowValidationScore) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m WorkflowValidationScore) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.workflowValidationScore
}

type WorkflowsGetResponse struct {
	CreationTime *string `json:"creationTime,omitempty"`
	Id           *string `json:"id,omitempty"`
	Name         *string `json:"name,omitempty"`
}
