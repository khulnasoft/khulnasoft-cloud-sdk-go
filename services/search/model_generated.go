/*
 * Copyright Â© 2022 Splunk, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"): you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 *
 * Splunk Search service
 *
 * Use the Search service in Splunk Cloud Services to dispatch, review, and manage searches and search jobs. You can finalize or cancel jobs, retrieve search results, and request search-related configurations from the Metadata Catalog service in Splunk Cloud Services.
 *
 * API version: v2 (recommended default)
 * Generated by: OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.
 */

package search

import (
	"bytes"
	"encoding/json"
)

// Dataset : A complete dataset as rendered in POST, PATCH responses.
type Dataset struct {
	federatedDataset    *FederatedDataset
	indexDataset        *IndexDataset
	kvCollectionDataset *KvCollectionDataset
	lookupDataset       *LookupDataset
	metricDataset       *MetricDataset
	raw                 interface{}
}

// MakeDatasetFromFederatedDataset creates a new Dataset from an instance of FederatedDataset
func MakeDatasetFromFederatedDataset(f FederatedDataset) Dataset {
	return Dataset{federatedDataset: &f}
}

// IsFederatedDataset checks if the Dataset is a FederatedDataset
func (m Dataset) IsFederatedDataset() bool {
	return m.federatedDataset != nil
}

// FederatedDataset returns FederatedDataset if IsFederatedDataset() is true, nil otherwise
func (m Dataset) FederatedDataset() *FederatedDataset {
	return m.federatedDataset
}

// MakeDatasetFromIndexDataset creates a new Dataset from an instance of IndexDataset
func MakeDatasetFromIndexDataset(f IndexDataset) Dataset {
	return Dataset{indexDataset: &f}
}

// IsIndexDataset checks if the Dataset is a IndexDataset
func (m Dataset) IsIndexDataset() bool {
	return m.indexDataset != nil
}

// IndexDataset returns IndexDataset if IsIndexDataset() is true, nil otherwise
func (m Dataset) IndexDataset() *IndexDataset {
	return m.indexDataset
}

// MakeDatasetFromKvCollectionDataset creates a new Dataset from an instance of KvCollectionDataset
func MakeDatasetFromKvCollectionDataset(f KvCollectionDataset) Dataset {
	return Dataset{kvCollectionDataset: &f}
}

// IsKvCollectionDataset checks if the Dataset is a KvCollectionDataset
func (m Dataset) IsKvCollectionDataset() bool {
	return m.kvCollectionDataset != nil
}

// KvCollectionDataset returns KvCollectionDataset if IsKvCollectionDataset() is true, nil otherwise
func (m Dataset) KvCollectionDataset() *KvCollectionDataset {
	return m.kvCollectionDataset
}

// MakeDatasetFromLookupDataset creates a new Dataset from an instance of LookupDataset
func MakeDatasetFromLookupDataset(f LookupDataset) Dataset {
	return Dataset{lookupDataset: &f}
}

// IsLookupDataset checks if the Dataset is a LookupDataset
func (m Dataset) IsLookupDataset() bool {
	return m.lookupDataset != nil
}

// LookupDataset returns LookupDataset if IsLookupDataset() is true, nil otherwise
func (m Dataset) LookupDataset() *LookupDataset {
	return m.lookupDataset
}

// MakeDatasetFromMetricDataset creates a new Dataset from an instance of MetricDataset
func MakeDatasetFromMetricDataset(f MetricDataset) Dataset {
	return Dataset{metricDataset: &f}
}

// IsMetricDataset checks if the Dataset is a MetricDataset
func (m Dataset) IsMetricDataset() bool {
	return m.metricDataset != nil
}

// MetricDataset returns MetricDataset if IsMetricDataset() is true, nil otherwise
func (m Dataset) MetricDataset() *MetricDataset {
	return m.metricDataset
}

// MakeDatasetFromRawInterface creates a new Dataset from a raw interface{}
func MakeDatasetFromRawInterface(f interface{}) Dataset {
	return Dataset{raw: f}
}

// IsRawInterface checks if the Dataset is an interface{} (unknown type)
func (m Dataset) IsRawInterface() bool {
	return m.raw != nil
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m Dataset) RawInterface() interface{} {
	return m.raw
}

// UnmarshalJSON unmarshals Dataset using the "kind" property
func (m *Dataset) UnmarshalJSON(b []byte) (err error) {
	type discriminator struct {
		Kind string `json:"kind"`
	}
	var d discriminator
	err = json.Unmarshal(b, &d)
	if err != nil {
		return err
	}
	// Resolve into respective struct based on the discriminator value
	switch d.Kind {
	case "federated":
		m.federatedDataset = &FederatedDataset{}
		return json.Unmarshal(b, m.federatedDataset)
	case "index":
		m.indexDataset = &IndexDataset{}
		return json.Unmarshal(b, m.indexDataset)
	case "kvcollection":
		m.kvCollectionDataset = &KvCollectionDataset{}
		return json.Unmarshal(b, m.kvCollectionDataset)
	case "lookup":
		m.lookupDataset = &LookupDataset{}
		return json.Unmarshal(b, m.lookupDataset)
	case "metric":
		m.metricDataset = &MetricDataset{}
		return json.Unmarshal(b, m.metricDataset)
	}
	// Unknown discriminator value (this type may not yet be supported)
	// unmarhsal to raw interface
	var raw interface{}
	err = json.Unmarshal(b, &raw)
	if err != nil {
		return err
	}
	m.raw = raw
	return nil
}

// MarshalJSON marshals Dataset using the appropriate struct field
func (m Dataset) MarshalJSON() ([]byte, error) {
	if m.IsFederatedDataset() {
		return json.Marshal(m.federatedDataset)
	} else if m.IsIndexDataset() {
		return json.Marshal(m.indexDataset)
	} else if m.IsKvCollectionDataset() {
		return json.Marshal(m.kvCollectionDataset)
	} else if m.IsLookupDataset() {
		return json.Marshal(m.lookupDataset)
	} else if m.IsMetricDataset() {
		return json.Marshal(m.metricDataset)
	}
	// None of the structs are populated, send raw
	return json.Marshal(m.raw)
}

// Properties that are common across all Dataset kinds rendered in POST, PATCH, and GET responses.
type DatasetCommon struct {
	// A unique dataset ID.
	Id string `json:"id"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The name of the namespace that contains the dataset.
	Namespace *string `json:"namespace,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
}

// DatasetPatch : Property values to be set in an existing dataset using a PATCH request.
// DatasetPatch is FederatedDatasetPatch, IndexDatasetPatch, KvCollectionDatasetPatch, LookupDatasetPatch, MetricDatasetPatch, (or interface{} if no matches are found)
type DatasetPatch struct {
	datasetPatch interface{}
	isRaw        bool
}

// UnmarshalJSON unmarshals DatasetPatch into FederatedDatasetPatch, IndexDatasetPatch, KvCollectionDatasetPatch, LookupDatasetPatch, MetricDatasetPatch, or interface{} if no matches are found
func (m *DatasetPatch) UnmarshalJSON(b []byte) (err error) {
	reader := bytes.NewReader(b)
	d := json.NewDecoder(reader)
	d.DisallowUnknownFields()
	// Attempt to unmarshal to each oneOf, if unknown fields then move to next
	attempt := func(m interface{}) error {
		_, err = reader.Seek(0, 0)
		if err != nil {
			return err
		}
		return d.Decode(m)
	}
	var testFederatedDatasetPatch FederatedDatasetPatch
	if err = attempt(&testFederatedDatasetPatch); err == nil {
		m.datasetPatch = testFederatedDatasetPatch
		return nil
	}
	var testIndexDatasetPatch IndexDatasetPatch
	if err = attempt(&testIndexDatasetPatch); err == nil {
		m.datasetPatch = testIndexDatasetPatch
		return nil
	}
	var testKvCollectionDatasetPatch KvCollectionDatasetPatch
	if err = attempt(&testKvCollectionDatasetPatch); err == nil {
		m.datasetPatch = testKvCollectionDatasetPatch
		return nil
	}
	var testLookupDatasetPatch LookupDatasetPatch
	if err = attempt(&testLookupDatasetPatch); err == nil {
		m.datasetPatch = testLookupDatasetPatch
		return nil
	}
	var testMetricDatasetPatch MetricDatasetPatch
	if err = attempt(&testMetricDatasetPatch); err == nil {
		m.datasetPatch = testMetricDatasetPatch
		return nil
	}
	// If no matches, decode model to raw interface
	var raw interface{}
	err = attempt(&raw)
	if err != nil {
		return err
	}
	m.isRaw = true
	m.datasetPatch = raw
	return nil
}

// MarshalJSON marshals DatasetPatch using DatasetPatch.DatasetPatch
func (m DatasetPatch) MarshalJSON() ([]byte, error) {
	return json.Marshal(m.datasetPatch)
}

// MakeDatasetPatchFromFederatedDatasetPatch creates a new DatasetPatch from an instance of FederatedDatasetPatch
func MakeDatasetPatchFromFederatedDatasetPatch(f FederatedDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsFederatedDatasetPatch checks if the DatasetPatch is a FederatedDatasetPatch
func (m DatasetPatch) IsFederatedDatasetPatch() bool {
	_, ok := m.datasetPatch.(FederatedDatasetPatch)
	return ok
}

// FederatedDatasetPatch returns FederatedDatasetPatch if IsFederatedDatasetPatch() is true, nil otherwise
func (m DatasetPatch) FederatedDatasetPatch() *FederatedDatasetPatch {
	if v, ok := m.datasetPatch.(FederatedDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromIndexDatasetPatch creates a new DatasetPatch from an instance of IndexDatasetPatch
func MakeDatasetPatchFromIndexDatasetPatch(f IndexDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsIndexDatasetPatch checks if the DatasetPatch is a IndexDatasetPatch
func (m DatasetPatch) IsIndexDatasetPatch() bool {
	_, ok := m.datasetPatch.(IndexDatasetPatch)
	return ok
}

// IndexDatasetPatch returns IndexDatasetPatch if IsIndexDatasetPatch() is true, nil otherwise
func (m DatasetPatch) IndexDatasetPatch() *IndexDatasetPatch {
	if v, ok := m.datasetPatch.(IndexDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromKvCollectionDatasetPatch creates a new DatasetPatch from an instance of KvCollectionDatasetPatch
func MakeDatasetPatchFromKvCollectionDatasetPatch(f KvCollectionDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsKvCollectionDatasetPatch checks if the DatasetPatch is a KvCollectionDatasetPatch
func (m DatasetPatch) IsKvCollectionDatasetPatch() bool {
	_, ok := m.datasetPatch.(KvCollectionDatasetPatch)
	return ok
}

// KvCollectionDatasetPatch returns KvCollectionDatasetPatch if IsKvCollectionDatasetPatch() is true, nil otherwise
func (m DatasetPatch) KvCollectionDatasetPatch() *KvCollectionDatasetPatch {
	if v, ok := m.datasetPatch.(KvCollectionDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromLookupDatasetPatch creates a new DatasetPatch from an instance of LookupDatasetPatch
func MakeDatasetPatchFromLookupDatasetPatch(f LookupDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsLookupDatasetPatch checks if the DatasetPatch is a LookupDatasetPatch
func (m DatasetPatch) IsLookupDatasetPatch() bool {
	_, ok := m.datasetPatch.(LookupDatasetPatch)
	return ok
}

// LookupDatasetPatch returns LookupDatasetPatch if IsLookupDatasetPatch() is true, nil otherwise
func (m DatasetPatch) LookupDatasetPatch() *LookupDatasetPatch {
	if v, ok := m.datasetPatch.(LookupDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromMetricDatasetPatch creates a new DatasetPatch from an instance of MetricDatasetPatch
func MakeDatasetPatchFromMetricDatasetPatch(f MetricDatasetPatch) DatasetPatch {
	return DatasetPatch{datasetPatch: f}
}

// IsMetricDatasetPatch checks if the DatasetPatch is a MetricDatasetPatch
func (m DatasetPatch) IsMetricDatasetPatch() bool {
	_, ok := m.datasetPatch.(MetricDatasetPatch)
	return ok
}

// MetricDatasetPatch returns MetricDatasetPatch if IsMetricDatasetPatch() is true, nil otherwise
func (m DatasetPatch) MetricDatasetPatch() *MetricDatasetPatch {
	if v, ok := m.datasetPatch.(MetricDatasetPatch); ok {
		return &v
	}
	return nil
}

// MakeDatasetPatchFromRawInterface creates a new DatasetPatch from a raw interface{}
func MakeDatasetPatchFromRawInterface(f interface{}) DatasetPatch {
	return DatasetPatch{
		datasetPatch: f,
		isRaw:        true,
	}
}

// IsRawInterface checks if the DatasetPatch is an interface{} (unknown type)
func (m DatasetPatch) IsRawInterface() bool {
	return m.isRaw
}

// RawInterface returns interface{} if IsRawInterface() is true (unknown type), nil otherwise
func (m DatasetPatch) RawInterface() interface{} {
	if !m.IsRawInterface() {
		return nil
	}
	return m.datasetPatch
}

// Properties that are common across all Dataset kinds to be set in an existing dataset using a PATCH request.
type DatasetPatchCommon struct {
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Properties that are common across all Dataset kinds for creating a new dataset using a POST request.
type DatasetPost struct {
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The fields to be associated with this dataset.
	Fields []FieldPost `json:"fields,omitempty"`
	// A unique dataset ID. Random ID used if not provided.
	Id *string `json:"id,omitempty"`
	// The name of the module to create the new dataset in.
	Module *string `json:"module,omitempty"`
}

// Created and Modified date-time properties for inclusion in other objects.
type DateMetadataProperties struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The date and time object was modified.
	Modified string `json:"modified"`
}

// A delete search job, including read-only fields that includes the required properties.
type DeleteSearchJob struct {
	// The index to delete the events from.
	Index string `json:"index"`
	// The module to run the delete search job in. The default module is used if the module field is empty.
	Module string `json:"module"`
	// The predicate expression that identifies the events to delete from the index. This expression must return true or false. To delete all events from the index, specify \"true\" instead of an expression.
	Predicate string `json:"predicate"`
	// Specifies that the delete search job contains side effects, with possible security risks.
	AllowSideEffects *bool `json:"allowSideEffects,omitempty"`
	// This property does not apply to delete search jobs endpoint and is set to false by default.
	CollectEventSummary *bool `json:"collectEventSummary,omitempty"`
	// This property does not apply to delete search jobs endpoint and is set to false by default.
	CollectFieldSummary *bool `json:"collectFieldSummary,omitempty"`
	// This property does not apply to delete search jobs endpoint and is set to false by default.
	CollectTimeBuckets *bool `json:"collectTimeBuckets,omitempty"`
	// The time, in GMT, that the search job is finished. Empty if the search job has not completed.
	CompletionTime *string `json:"completionTime,omitempty"`
	// The time, in GMT, that the search job is dispatched.
	DispatchTime *string `json:"dispatchTime,omitempty"`
	// This property does not apply to delete search jobs endpoint and is set to false by default.
	EnablePreview *bool `json:"enablePreview,omitempty"`
	// Specifies how the Search service should extract fields. Valid values include 'all', 'none', or 'indexed'. 'all' will extract all fields, 'indexed' will extract only indexed fields, and 'none' will extract only the default fields. This parameter overwrites the value of the 'extractAllFields' parameter. Set to 'none' for better search performance.
	ExtractFields *string `json:"extractFields,omitempty"`
	// The amount of time, in seconds, to run the delete search job before finalizing the search. The maximum value is 3600 seconds (1 hour).
	MaxTime  *int32    `json:"maxTime,omitempty"`
	Messages []Message `json:"messages,omitempty"`
	// The name of the search job.
	Name *string `json:"name,omitempty"`
	// An estimate of the percent of time remaining before the delete search job completes.
	PercentComplete *int32 `json:"percentComplete,omitempty"`
	// This property does not apply to delete search jobs endpoint and is set to false by default.
	PreviewAvailable *string `json:"previewAvailable,omitempty"`
	// The SPL search string that includes the index, module, and predicate that you specify.
	Query *string `json:"query,omitempty"`
	// Represents parameters on the search job such as 'earliest' and 'latest'.
	QueryParameters *QueryParameters `json:"queryParameters,omitempty"`
	// This property does not apply to delete search jobs endpoint and is set to 0 by default.
	RequiredFreshness *int32 `json:"requiredFreshness,omitempty"`
	// The earliest time specified as an absolute value in GMT. The time is computed based on the values you specify for the 'timezone' and 'earliest' queryParameters.
	ResolvedEarliest *string `json:"resolvedEarliest,omitempty"`
	// The latest time specified as an absolute value in GMT. The time is computed based on the values you specify for the 'timezone' and 'earliest' queryParameters.
	ResolvedLatest *string `json:"resolvedLatest,omitempty"`
	// The number of results produced so far by the delete search job that are going to be deleted.
	ResultsAvailable *int32 `json:"resultsAvailable,omitempty"`
	// This property does not apply to delete search jobs endpoint and is set to 0 by default.
	ResultsPreviewAvailable *int32 `json:"resultsPreviewAvailable,omitempty"`
	// The ID assigned to the delete search job.
	Sid    *string       `json:"sid,omitempty"`
	Status *SearchStatus `json:"status,omitempty"`
}

// A fully constructed federated connection object.
type FederatedConnection struct {
	// The timestamp when the federated connection was created.
	Created *string `json:"created,omitempty"`
	// The user who created the federated connection.
	Createdby *string `json:"createdby,omitempty"`
	// The remote hostname to connect yo.
	Hostnameip *string `json:"hostnameip,omitempty"`
	// The timestamp when the federated connection was modified.
	Modified *string `json:"modified,omitempty"`
	// The user who last modified the federated connection.
	Modifiedby *string `json:"modifiedby,omitempty"`
	// The name of the federated connection.
	Name *string `json:"name,omitempty"`
	// The remote port number.
	Port *float32 `json:"port,omitempty"`
	// The username on the service account.
	Serviceaccountuser *string `json:"serviceaccountuser,omitempty"`
}

// The property values for creating a new federated connection using a PUT or POST request.
type FederatedConnectionInput struct {
	// The remote hostname to connect to.
	Hostnameip string `json:"hostnameip"`
	// The name of the federated connection.
	Name string `json:"name"`
	// The remote port number.
	Port float32 `json:"port"`
	// The password of the service account.
	Serviceaccountpassword string `json:"serviceaccountpassword"`
	// The username on the service account.
	Serviceaccountuser string `json:"serviceaccountuser"`
}

// A complete federated dataset as rendered in POST, PATCH, and GET responses.
type FederatedDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// Connection information to connect to remote federated connection.
	FederatedConnection string `json:"federatedConnection"`
	// Dataset information in the remote instance.
	FederatedDataset string `json:"federatedDataset"`
	// Dataset kind information in the remote instance.
	FederatedDatasetKind string `json:"federatedDatasetKind"`
	// A unique dataset ID.
	Id   string               `json:"id"`
	Kind FederatedDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The name of the namespace that contains the dataset.
	Namespace *string `json:"namespace,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
}

// FederatedDatasetKind : The dataset kind.
type FederatedDatasetKind string

// List of FederatedDatasetKind
const (
	FederatedDatasetKindFederated FederatedDatasetKind = "federated"
)

// Property values to be set in an existing federated dataset using a PATCH request.
type FederatedDatasetPatch struct {
	// Connection information to connect to remote federated connection.
	FederatedConnection *string `json:"federatedConnection,omitempty"`
	// Dataset information in the remote instance.
	FederatedDataset *string `json:"federatedDataset,omitempty"`
	// Dataset kind information in the remote instance.
	FederatedDatasetKind *string               `json:"federatedDatasetKind,omitempty"`
	Kind                 *FederatedDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Properties of job datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type FederatedDatasetProperties struct {
	// Connection information to connect to remote federated connection.
	FederatedConnection *string `json:"federatedConnection,omitempty"`
	// Dataset information in the remote instance.
	FederatedDataset *string `json:"federatedDataset,omitempty"`
	// Dataset kind information in the remote instance.
	FederatedDatasetKind *string               `json:"federatedDatasetKind,omitempty"`
	Kind                 *FederatedDatasetKind `json:"kind,omitempty"`
}

// FieldDataType : The type of data in the field. Must be one of the valid values.
type FieldDataType string

// List of FieldDataType
const (
	FieldDataTypeDate     FieldDataType = "DATE"
	FieldDataTypeNumber   FieldDataType = "NUMBER"
	FieldDataTypeObjectId FieldDataType = "OBJECT_ID"
	FieldDataTypeString   FieldDataType = "STRING"
	FieldDataTypeUnknown  FieldDataType = "UNKNOWN"
)

// Initial property values for creating a new field using a POST request.
type FieldPost struct {
	// The field name.
	Name     string         `json:"name"`
	Datatype *FieldDataType `json:"datatype,omitempty"`
	// The field description.
	Description *string    `json:"description,omitempty"`
	Fieldtype   *FieldType `json:"fieldtype,omitempty"`
	// Whether or not the field has been indexed.
	Indexed    *bool            `json:"indexed,omitempty"`
	Prevalence *FieldPrevalence `json:"prevalence,omitempty"`
	// The field summary.
	Summary *string `json:"summary,omitempty"`
	// The field title.
	Title *string `json:"title,omitempty"`
}

// FieldPrevalence : How frequent the field appears in the dataset. Must be one of the valid values.
type FieldPrevalence string

// List of FieldPrevalence
const (
	FieldPrevalenceAll     FieldPrevalence = "ALL"
	FieldPrevalenceSome    FieldPrevalence = "SOME"
	FieldPrevalenceUnknown FieldPrevalence = "UNKNOWN"
)

// Properties of fields which can be read, set, and changed through the API. Implementation detail of FieldPOST, FieldPATCH, and Field, do not use directly.
type FieldProperties struct {
	Datatype *FieldDataType `json:"datatype,omitempty"`
	// The field description.
	Description *string    `json:"description,omitempty"`
	Fieldtype   *FieldType `json:"fieldtype,omitempty"`
	// Whether or not the field has been indexed.
	Indexed *bool `json:"indexed,omitempty"`
	// The field name.
	Name       *string          `json:"name,omitempty"`
	Prevalence *FieldPrevalence `json:"prevalence,omitempty"`
	// The field summary.
	Summary *string `json:"summary,omitempty"`
	// The field title.
	Title *string `json:"title,omitempty"`
}

// FieldType : The type of field. Must be one of the valid values.
type FieldType string

// List of FieldType
const (
	FieldTypeDimension FieldType = "DIMENSION"
	FieldTypeMeasure   FieldType = "MEASURE"
	FieldTypeUnknown   FieldType = "UNKNOWN"
)

// A  statistical summary of the fields in the events to date, for the search ID (SID).
type FieldsSummary struct {
	// The amount of time, in seconds, that a time bucket spans from the earliest to the latest time.
	Duration *float64 `json:"duration,omitempty"`
	// The earliest timestamp, in UTC format, of the events to process.
	EarliestTime *string `json:"earliestTime,omitempty"`
	// The total number of events for all fields returned in the time range (earliestTime and latestTime) specified.
	EventCount *int32 `json:"eventCount,omitempty"`
	// A list of the fields in the time range specified.
	Fields map[string]SingleFieldSummary `json:"fields,omitempty"`
	// The latest timestamp, in UTC format, of the events to process.
	LatestTime *string `json:"latestTime,omitempty"`
}

// A complete index dataset as rendered in POST, PATCH, and GET responses.
type IndexDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// Specifies whether or not the Splunk index is disabled.
	Disabled bool `json:"disabled"`
	// A unique dataset ID.
	Id   string           `json:"id"`
	Kind IndexDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The timestamp, in seconds, of the earliest event. The timestamp is in UNIX time.
	EarliestEventTime *string `json:"earliestEventTime,omitempty"`
	// The earliest index time for any of the events in this index.
	EarliestIngestTime *string `json:"earliestIngestTime,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32 `json:"frozenTimePeriodInSecs,omitempty"`
	// The timestamp, in seconds, of the latest event. The timestamp is in UNIX time.
	LatestEventTime *string `json:"latestEventTime,omitempty"`
	// The latest index time for any of the events in this index.
	LatestIngestTime *string `json:"latestIngestTime,omitempty"`
	// The latest time that the index metadata was refreshed.
	LatestMetadataUpdateTime *string `json:"latestMetadataUpdateTime,omitempty"`
	// The name of the namespace that contains the dataset.
	Namespace *string `json:"namespace,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// The number of events in the index.
	TotalEventCount *int64 `json:"totalEventCount,omitempty"`
	// The raw size, in bytes, of the uncompressed data in the indexers.
	TotalSize *int64 `json:"totalSize,omitempty"`
}

// IndexDatasetKind : The dataset kind.
type IndexDatasetKind string

// List of IndexDatasetKind
const (
	IndexDatasetKindIndex IndexDatasetKind = "index"
)

// Property values to be set in an existing index dataset using a PATCH request.
type IndexDatasetPatch struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32            `json:"frozenTimePeriodInSecs,omitempty"`
	Kind                   *IndexDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Properties of job datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type IndexDatasetProperties struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32            `json:"frozenTimePeriodInSecs,omitempty"`
	Kind                   *IndexDatasetKind `json:"kind,omitempty"`
}

// Properties of index datasets which can only be read through the API.
type IndexDatasetReadOnlyProperties struct {
	// The timestamp, in seconds, of the earliest event. The timestamp is in UNIX time.
	EarliestEventTime *string `json:"earliestEventTime,omitempty"`
	// The earliest index time for any of the events in this index.
	EarliestIngestTime *string           `json:"earliestIngestTime,omitempty"`
	Kind               *IndexDatasetKind `json:"kind,omitempty"`
	// The timestamp, in seconds, of the latest event. The timestamp is in UNIX time.
	LatestEventTime *string `json:"latestEventTime,omitempty"`
	// The latest index time for any of the events in this index.
	LatestIngestTime *string `json:"latestIngestTime,omitempty"`
	// The latest time that the index metadata was refreshed.
	LatestMetadataUpdateTime *string `json:"latestMetadataUpdateTime,omitempty"`
	// The number of events in the index.
	TotalEventCount *int64 `json:"totalEventCount,omitempty"`
	// The raw size, in bytes, of the uncompressed data in the indexers.
	TotalSize *int64 `json:"totalSize,omitempty"`
}

// A complete kvcollection dataset as rendered in POST, PATCH, and GET responses.
type KvCollectionDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// A unique dataset ID.
	Id   string                  `json:"id"`
	Kind KvCollectionDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The name of the namespace that contains the dataset.
	Namespace *string `json:"namespace,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
}

// KvCollectionDatasetKind : The dataset kind.
type KvCollectionDatasetKind string

// List of KVCollectionDatasetKind
const (
	KvCollectionDatasetKindKvcollection KvCollectionDatasetKind = "kvcollection"
)

// Property values to be set in an existing kvcollection dataset using a PATCH request.
type KvCollectionDatasetPatch struct {
	Kind *KvCollectionDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Properties of kvcollection datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type KvCollectionDatasetProperties struct {
	Kind *KvCollectionDatasetKind `json:"kind,omitempty"`
}

// A list of fully constructed datasets
type ListDatasets struct {
	// List of all datasets
	Results []Dataset `json:"results,omitempty"`
}

// A list of federated connections
type ListFederatedConnections []FederatedConnection

// The structure of the response body for the preview search results that is returned for the job with the specified search ID (SID). When search is running, it might return incomplete or truncated search results. The isPreviewStable property indicates whether the returned preview results stucture is stable or not. Truncated preview results occur because the number of requested results exceeds the page limit. Use the 'nextLink' URL to retrieve the next page of results.
type ListPreviewResultsResponse struct {
	IsPreviewStable bool                               `json:"isPreviewStable"`
	Results         []map[string]interface{}           `json:"results"`
	Fields          []ListPreviewResultsResponseFields `json:"fields,omitempty"`
	Messages        []Message                          `json:"messages,omitempty"`
	NextLink        *string                            `json:"nextLink,omitempty"`
	Wait            *string                            `json:"wait,omitempty"`
}

type ListPreviewResultsResponseFields struct {
	Name           string  `json:"name"`
	DataSource     *string `json:"dataSource,omitempty"`
	GroupbyRank    *string `json:"groupbyRank,omitempty"`
	SplitField     *string `json:"splitField,omitempty"`
	SplitValue     *string `json:"splitValue,omitempty"`
	SplitbySpecial *string `json:"splitbySpecial,omitempty"`
	TypeSpecial    *string `json:"typeSpecial,omitempty"`
}

// The structure of the  search results or events metadata that is returned for the job with the specified search ID (SID). When search is running, it might return incomplete or truncated search results. Incomplete search results occur when a search has not completed. Wait until search completes for full result set. Truncated search results occur because the number of requested results exceeds the page limit. Use the 'nextLink' URL to retrieve the next page of results.
type ListSearchResultsResponse struct {
	Results  []map[string]interface{}           `json:"results"`
	Fields   []ListPreviewResultsResponseFields `json:"fields,omitempty"`
	Messages []Message                          `json:"messages,omitempty"`
	NextLink *string                            `json:"nextLink,omitempty"`
	Wait     *string                            `json:"wait,omitempty"`
}

// A complete lookup dataset as rendered in POST, PATCH, and GET responses.
type LookupDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby    string                    `json:"createdby"`
	ExternalKind LookupDatasetExternalKind `json:"externalKind"`
	// The name of the external lookup.
	ExternalName string `json:"externalName"`
	// A unique dataset ID.
	Id   string            `json:"id"`
	Kind LookupDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Match case-sensitively against the lookup.
	CaseSensitiveMatch *bool `json:"caseSensitiveMatch,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// A query that filters results out of the lookup before those results are returned.
	Filter *string `json:"filter,omitempty"`
	// The name of the namespace that contains the dataset.
	Namespace *string `json:"namespace,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
}

// LookupDatasetExternalKind : The type of the external lookup.
type LookupDatasetExternalKind string

// List of LookupDatasetExternalKind
const (
	LookupDatasetExternalKindKvcollection LookupDatasetExternalKind = "kvcollection"
)

// LookupDatasetKind : The dataset kind.
type LookupDatasetKind string

// List of LookupDatasetKind
const (
	LookupDatasetKindLookup LookupDatasetKind = "lookup"
)

// Property values to be set in an existing lookup dataset using a PATCH request.
type LookupDatasetPatch struct {
	// Match case-sensitively against the lookup.
	CaseSensitiveMatch *bool                      `json:"caseSensitiveMatch,omitempty"`
	ExternalKind       *LookupDatasetExternalKind `json:"externalKind,omitempty"`
	// The name of the external lookup.
	ExternalName *string `json:"externalName,omitempty"`
	// A query that filters results out of the lookup before those results are returned.
	Filter *string            `json:"filter,omitempty"`
	Kind   *LookupDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Properties of lookup datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type LookupDatasetProperties struct {
	// Match case-sensitively against the lookup.
	CaseSensitiveMatch *bool                      `json:"caseSensitiveMatch,omitempty"`
	ExternalKind       *LookupDatasetExternalKind `json:"externalKind,omitempty"`
	// The name of the external lookup.
	ExternalName *string `json:"externalName,omitempty"`
	// A query that filters results out of the lookup before those results are returned.
	Filter *string            `json:"filter,omitempty"`
	Kind   *LookupDatasetKind `json:"kind,omitempty"`
}

// The message field in search results or search jobs. The types of messages are INFO, DEBUG, FATAL, and ERROR.
type Message struct {
	Text *string      `json:"text,omitempty"`
	Type *MessageType `json:"type,omitempty"`
}

type MessageType string

// List of MessageType
const (
	MessageTypeInfo  MessageType = "INFO"
	MessageTypeDebug MessageType = "DEBUG"
	MessageTypeFatal MessageType = "FATAL"
	MessageTypeError MessageType = "ERROR"
)

// Created, createdby, modified, modifiedby, and owner properties for inclusion in other objects.
type MetadataProperties struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the object's owner.
	Owner string `json:"owner"`
}

// A complete metric dataset as rendered in POST, PATCH, and GET responses.
type MetricDataset struct {
	// The date and time object was created.
	Created string `json:"created"`
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// Specifies whether or not the Splunk index is disabled.
	Disabled bool `json:"disabled"`
	// A unique dataset ID.
	Id   string            `json:"id"`
	Kind MetricDatasetKind `json:"kind"`
	// The date and time object was modified.
	Modified string `json:"modified"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The dataset name. Dataset names must be unique within each module.
	Name string `json:"name"`
	// The name of the object's owner.
	Owner string `json:"owner"`
	// The dataset name qualified by the module name.
	Resourcename string `json:"resourcename"`
	// AppClinetId of the creator app of the dataset.
	Appclientidcreatedby *string `json:"appclientidcreatedby,omitempty"`
	// AppClinetId of the modifier app of the dataset.
	Appclientidmodifiedby *string `json:"appclientidmodifiedby,omitempty"`
	// Detailed description of the dataset.
	Description *string `json:"description,omitempty"`
	// The timestamp, in seconds, of the earliest measure. The timestamp is in UNIX time.
	EarliestEventTime *string `json:"earliestEventTime,omitempty"`
	// The earliest index time for any of the measures in this index.
	EarliestIngestTime *string `json:"earliestIngestTime,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32 `json:"frozenTimePeriodInSecs,omitempty"`
	// The timestamp, in seconds, of the latest measure. The timestamp is in UNIX time.
	LatestEventTime *string `json:"latestEventTime,omitempty"`
	// The earliest index time for any of the measures in this index.
	LatestIngestTime *string `json:"latestIngestTime,omitempty"`
	// The latest time that the metric index metadata was refreshed.
	LatestMetadataUpdateTime *string `json:"latestMetadataUpdateTime,omitempty"`
	// The name of the namespace that contains the dataset.
	Namespace *string `json:"namespace,omitempty"`
	// Summary of the dataset's purpose.
	Summary *string `json:"summary,omitempty"`
	// The title of the dataset.  Does not have to be unique.
	Title *string `json:"title,omitempty"`
	// THe number of measures in the metric index.
	TotalEventCount *int32 `json:"totalEventCount,omitempty"`
	// For metrics indexes, the totalSize is set to 0.
	TotalSize *int32 `json:"totalSize,omitempty"`
}

// MetricDatasetKind : The dataset kind.
type MetricDatasetKind string

// List of MetricDatasetKind
const (
	MetricDatasetKindMetric MetricDatasetKind = "metric"
)

// Property values to be set in an existing metric dataset using a PATCH request.
type MetricDatasetPatch struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32             `json:"frozenTimePeriodInSecs,omitempty"`
	Kind                   *MetricDatasetKind `json:"kind,omitempty"`
	// The name of module to reassign dataset into.
	Module *string `json:"module,omitempty"`
	// The dataset name. Dataset names must be unique within each module.
	Name *string `json:"name,omitempty"`
	// The name of the dataset owner. This value is obtained from the bearer token.
	Owner *string `json:"owner,omitempty"`
}

// Properties of metric datasets which may be read, set, and changed through the API. Implementation detail of DatasetPOST, DatasetPATCH, and Dataset, do not use directly.
type MetricDatasetProperties struct {
	// Specifies whether or not the Splunk index is disabled.
	Disabled *bool `json:"disabled,omitempty"`
	// The frozenTimePeriodInSecs to use for the index
	FrozenTimePeriodInSecs *int32             `json:"frozenTimePeriodInSecs,omitempty"`
	Kind                   *MetricDatasetKind `json:"kind,omitempty"`
}

// Properties of metric datasets which can only be read through the API.
type MetricDatasetReadOnlyProperties struct {
	// The timestamp, in seconds, of the earliest measure. The timestamp is in UNIX time.
	EarliestEventTime *string `json:"earliestEventTime,omitempty"`
	// The earliest index time for any of the measures in this index.
	EarliestIngestTime *string            `json:"earliestIngestTime,omitempty"`
	Kind               *MetricDatasetKind `json:"kind,omitempty"`
	// The timestamp, in seconds, of the latest measure. The timestamp is in UNIX time.
	LatestEventTime *string `json:"latestEventTime,omitempty"`
	// The earliest index time for any of the measures in this index.
	LatestIngestTime *string `json:"latestIngestTime,omitempty"`
	// The latest time that the metric index metadata was refreshed.
	LatestMetadataUpdateTime *string `json:"latestMetadataUpdateTime,omitempty"`
	// THe number of measures in the metric index.
	TotalEventCount *int32 `json:"totalEventCount,omitempty"`
	// For metrics indexes, the totalSize is set to 0.
	TotalSize *int32 `json:"totalSize,omitempty"`
}

// Represents parameters on the search job such as 'earliest' and 'latest'.
type QueryParameters struct {
	// The earliest time, in absolute or relative format, to retrieve events. When specifying an absolute time specify either UNIX time, or UTC in seconds using the ISO-8601 (%FT%T.%Q) format. For example 2021-01-25T13:15:30Z. GMT is the default timezone. You must specify GMT when you specify UTC. Any offset specified is ignored. Latest time must be after Earliest time.
	Earliest *string `json:"earliest,omitempty"`
	// The latest time, in absolute or relative format, to retrieve events. When specifying an absolute time specify either UNIX time, or UTC in seconds using the ISO-8601 (%FT%T.%Q) format. For example 2021-01-25T13:15:30Z. GMT is the default timezone. You must specify GMT when you specify UTC. Any offset specified is ignored. Latest time must be after Earliest time.
	Latest *string `json:"latest,omitempty"`
	// Specify a time string to set the absolute time used for any relative time specifier in the search. Defaults to the current system time. You can specify a relative time modifier ('earliest' or 'latest') for this parameter.  For example, if 'earliest' is set to -d and  the 'relativeTimeAnchor' is set to '2021-01-05T13:15:30Z' then 'resolvedEarliest' is '2021-01-04T13:15:30Z'.
	RelativeTimeAnchor *string `json:"relativeTimeAnchor,omitempty"`
	// The timezone that relative time modifiers are based off of. Timezone only applies to relative time literals for 'earliest' and 'latest'. If UNIX time or UTC format is used for 'earliest' and 'latest', this field is ignored. For the list of supported timezone formats, see https://docs.splunk.com/Documentation/Splunk/latest/Data/Applytimezoneoffsetstotimestamps#zoneinfo_.28TZ.29_database type: string default: \"GMT\"
	Timezone interface{} `json:"timezone,omitempty"`
}

// A search job, including read-only fields that includes the required properties.
type SearchJob struct {
	// The SPL search string.
	Query string `json:"query"`
	// Specifies whether a search that contains commands with side effects (with possible security risks) is allowed to run.
	AllowSideEffects *bool `json:"allowSideEffects,omitempty"`
	// Specifies whether a search is allowed to collect event summary information during the run time.
	CollectEventSummary *bool `json:"collectEventSummary,omitempty"`
	// Specifies whether a search is allowed to collect field summary information during the run time.
	CollectFieldSummary *bool `json:"collectFieldSummary,omitempty"`
	// Specifies whether a search is allowed to collect timeline bucket summary information during the run time.
	CollectTimeBuckets *bool `json:"collectTimeBuckets,omitempty"`
	// The time, in GMT, that the search job is finished. Empty if the search job has not completed.
	CompletionTime *string `json:"completionTime,omitempty"`
	// The time, in GMT, that the search job is dispatched.
	DispatchTime *string `json:"dispatchTime,omitempty"`
	// Specifies whether a search is allowed to collect preview results during the run time.
	EnablePreview *bool `json:"enablePreview,omitempty"`
	// Specifies whether the Search service should extract all of the available fields in the data, including fields not mentioned in the SPL, for the search job. Set to 'false' for better search performance. The 'extractAllFields' parameter is deprecated as of version v3alpha1. Although this parameter continues to function, it might be removed in a future version. Use the 'extractFields' parameter instead.
	ExtractAllFields *bool `json:"extractAllFields,omitempty"`
	// Specifies how the Search service should extract fields. Valid values include 'all', 'none', or 'indexed'.  Use 'all' to extract all fields. Use 'indexed' to extract only indexed fields. Use 'none' to extract only the default fields.
	ExtractFields *string `json:"extractFields,omitempty"`
	// The number of seconds to run the search before finalizing the search. The maximum value is 3600 seconds (1 hour).
	MaxTime  *int32    `json:"maxTime,omitempty"`
	Messages []Message `json:"messages,omitempty"`
	// The module to run the search in. The default module is used if a module is not specified.
	Module *string `json:"module,omitempty"`
	// The name of the search job.
	Name *string `json:"name,omitempty"`
	// An estimate of the percent of time remaining before the job completes.
	PercentComplete *int32 `json:"percentComplete,omitempty"`
	// Specifies if preview results for the search job are available. The valid status values are 'unknown', 'true', and 'false'. You must set the 'enablePreview=true' parameter to return preview search results.
	PreviewAvailable *string `json:"previewAvailable,omitempty"`
	// Represents parameters on the search job such as 'earliest' and 'latest'.
	QueryParameters *QueryParameters `json:"queryParameters,omitempty"`
	// Specifies a maximum time interval, in seconds, between identical existing searches. The 'requiredFreshness' parameter is used to determine if an existing search with the same query and the same time boundaries can be reused, instead of running the same search again. Freshness is applied to the 'resolvedEarliest' and 'resolvedLatest' parameters. If an existing search has the same exact criteria as this search and the 'resolvedEarliest' and 'resolvedLatest' values are within the freshness interval, the existing search metadata is returned instead of initiating a new search job. By default, the 'requiredFreshness' parameter is set to 0 which means that the platform does not attempt to use an existing search. The maximum value for the 'requiredFreshness' parameter is 259200 seconds (72 hours).
	RequiredFreshness *int32 `json:"requiredFreshness,omitempty"`
	// The earliest time specified as an absolute value in GMT. The time is computed based on the values you specify for the 'timezone' and 'earliest' queryParameters.
	ResolvedEarliest *string `json:"resolvedEarliest,omitempty"`
	// The latest time specified as an absolute value in GMT. The time is computed based on the values you specify for the 'timezone' and 'earliest' queryParameters.
	ResolvedLatest *string `json:"resolvedLatest,omitempty"`
	// The number of results produced so far for the search job.
	ResultsAvailable *int32 `json:"resultsAvailable,omitempty"`
	// The number of the preview search results for the job with the specified search ID (SID). You must set the 'enablePreview=true' parameter to return preview search results.
	ResultsPreviewAvailable *int32 `json:"resultsPreviewAvailable,omitempty"`
	// The ID assigned to the search job.
	Sid    *string       `json:"sid,omitempty"`
	Status *SearchStatus `json:"status,omitempty"`
}

// SearchStatus : The current status of the search job. The valid status values are 'running', 'done', 'canceled', 'finalized' and 'failed'.
type SearchStatus string

// List of SearchStatus
const (
	SearchStatusRunning   SearchStatus = "running"
	SearchStatusDone      SearchStatus = "done"
	SearchStatusCanceled  SearchStatus = "canceled"
	SearchStatusFailed    SearchStatus = "failed"
	SearchStatusFinalized SearchStatus = "finalized"
)

// Summary of each field.
type SingleFieldSummary struct {
	// The total number of events that the field appears in.
	Count *int32 `json:"count,omitempty"`
	// The total number of unique values in the field.
	DistinctCount *int32 `json:"distinctCount,omitempty"`
	// Specifies if the 'distinctCount' is accurate. When the count exceeds the maximum count, an approximate count is computed instead and the 'isExact' property is FALSE.
	IsExact *bool `json:"isExact,omitempty"`
	// The maximum numeric value in the field.
	Max *string `json:"max,omitempty"`
	// The mean (average) for the numeric value in the field.
	Mean *float64 `json:"mean,omitempty"`
	// The minimum numeric value in the field.
	Min *string `json:"min,omitempty"`
	// An array of the values in the field.
	Modes []SingleValueMode `json:"modes,omitempty"`
	// The count of the numeric values in the field.
	NumericCount *int32 `json:"numericCount,omitempty"`
	// Specifies if the field was added or changed by the search.
	Relevant *bool `json:"relevant,omitempty"`
	// The standard deviation for the numeric values in the field.
	Stddev *float64 `json:"stddev,omitempty"`
}

// The summary of events for a single time bucket.
type SingleTimeBucket struct {
	// Count of available events. Not all events in a bucket are retrievable. Typically this count is capped at 10000.
	AvailableCount *int32   `json:"availableCount,omitempty"`
	Duration       *float64 `json:"duration,omitempty"`
	// The timestamp of the earliest event in the current bucket, in UNIX format. This is the same time as 'earliestTimeStrfTime' in UNIX format.
	EarliestTime *float64 `json:"earliestTime,omitempty"`
	// The timestamp of the earliest event in the current bucket, in UTC format with seconds. For example 2021-01-25T13:15:30Z, which follows the ISO-8601 (%FT%T.%Q) format.
	EarliestTimeStrfTime *string `json:"earliestTimeStrfTime,omitempty"`
	// Specifies if all of the events in the current bucket have been finalized.
	IsFinalized *bool `json:"isFinalized,omitempty"`
	// The total count of the events in the current bucket.
	TotalCount *int32 `json:"totalCount,omitempty"`
}

// Summary of the value in a field.
type SingleValueMode struct {
	// The number of occurrences that the value appears in a field.
	Count *int32 `json:"count,omitempty"`
	// Specifies if the count is accurate. When the count exceeds the maximum count, an approximate count is computed instead and the 'isExact' property is FALSE.
	IsExact *bool `json:"isExact,omitempty"`
	// The value in the field.
	Value *string `json:"value,omitempty"`
}

// A timeline metadata model of the event distribution. The model shows the untransformed events that are read to date for a specific for search ID (SID).
type TimeBucketsSummary struct {
	// Specifies if the events are returned in time order.
	IsTimeCursored *bool              `json:"IsTimeCursored,omitempty"`
	Buckets        []SingleTimeBucket `json:"buckets,omitempty"`
	// Identifies where the cursor is in processing the events. The 'cursorTime' is a timestamp specified in UNIX time.
	CursorTime *float32 `json:"cursorTime,omitempty"`
	// The number of events processed at the 'cursorTime'.
	EventCount *int32 `json:"eventCount,omitempty"`
}

// Updates a search job with a status.
type UpdateJob struct {
	// Modify the status of an existing search job using PATCH. The only status values you can PATCH are 'canceled' and 'finalized'.  You can PATCH the 'canceled' status only to a search job that is running. 'finalize' means to terminate the search job, and the status will be set to 'failed'.
	Status UpdateJobStatus `json:"status"`
}

// UpdateJobStatus : Modify the status of an existing search job using PATCH. The only status values you can PATCH are 'canceled' and 'finalized'.  You can PATCH the 'canceled' status only to a search job that is running. 'finalize' means to terminate the search job, and the status will be set to 'failed'.
type UpdateJobStatus string

// List of UpdateJobStatus
const (
	UpdateJobStatusCanceled  UpdateJobStatus = "canceled"
	UpdateJobStatusFinalized UpdateJobStatus = "finalized"
)

// Owner, createdby, and modifiedby user name properties for inclusion in other objects.
type UserMetadataProperties struct {
	// The name of the user who created the object. This value is obtained from the bearer token and may not be changed.
	Createdby string `json:"createdby"`
	// The name of the user who most recently modified the object.
	Modifiedby string `json:"modifiedby"`
	// The name of the object's owner.
	Owner string `json:"owner"`
}
